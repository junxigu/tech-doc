<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">






<link rel="stylesheet" type="text/css" href="index.css" media="all">
</head>
<body topmargin="5" leftmargin="0" marginheight="5" marginwidth="0"><div id="bd_snap">
    <div id="bd_snap_head">
        <a href="http://www.baidu.com/" id="bd_snap_logo" title="到百度首页"></a>
    </div>
    <div id="bd_snap_txt">您查询的关键词是：<span><a style="color: black; background-color: rgb(255, 255, 102); padding: 0pt 3px; font-weight: bold;" href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52&amp;p=9874de15d9c041a902be9b754c0892&amp;user=baidu&amp;fm=sc&amp;query=socket+hostent%B5%C4%CA%B9%D3%C3&amp;qid=c7365c2b254eac06&amp;p1=4#baidusnap0">socket</a><a style="color: black; background-color: rgb(160, 255, 255); padding: 0pt 3px; font-weight: bold;" href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52&amp;p=9874de15d9c041a902be9b754c0892&amp;user=baidu&amp;fm=sc&amp;query=socket+hostent%B5%C4%CA%B9%D3%C3&amp;qid=c7365c2b254eac06&amp;p1=4#baidusnap1">hostent</a><a style="color: black; background-color: rgb(153, 255, 153); padding: 0pt 3px; font-weight: bold;" href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52&amp;p=9874de15d9c041a902be9b754c0892&amp;user=baidu&amp;fm=sc&amp;query=socket+hostent%B5%C4%CA%B9%D3%C3&amp;qid=c7365c2b254eac06&amp;p1=4#baidusnap2">的</a><a style="color: black; background-color: rgb(255, 153, 153); padding: 0pt 3px; font-weight: bold;" href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52&amp;p=9874de15d9c041a902be9b754c0892&amp;user=baidu&amp;fm=sc&amp;query=socket+hostent%B5%C4%CA%B9%D3%C3&amp;qid=c7365c2b254eac06&amp;p1=4#baidusnap3">使用</a></span> 。如果打开速度慢，可以尝试<a href="http://cache.baidu.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52&amp;p=9874de15d9c041a902be9b754c0892&amp;user=baidu&amp;fm=sc&amp;query=socket+hostent%B5%C4%CA%B9%D3%C3&amp;qid=c7365c2b254eac06&amp;p1=4&amp;fast=y">快速版</a>；如果想保存快照，可以<a onclick="window.open('http://cang.baidu.com/do/add?it='+encodeURIComponent(document.title)+'&amp;iu='+encodeURIComponent(location.href)+'&amp;fr=ps#nw=1','_s','scrollbars=no,width=600,height=450,right=75,top=20,status=no,resizable=yes'); return false;" href="http://cang.baidu.com/do/add" target="_top">添加到搜藏</a>；如果想更新或删除快照，可以<a href="http://tousu.baidu.com/webmaster/add?link=http%3A%2F%2Fcache.baidu.com%2Fc%3Fm%3D9f65cb4a8c8507ed4fece763105392230e54f732668c8c463888c80284642c1d1020fee37d3f1003cec3766707a55e5c9daa702d691765eadb9e870b80eacb7f699f27452a41c707458f5fb8ca3632b127872befb81897ad814184ded9c4a95544bb52%26p%3D9874de15d9c041a902be9b754c0892%26user%3Dbaidu%26fm%3Dsc%26query%3Dsocket%2Bhostent%25B5%25C4%25CA%25B9%25D3%25C3%26qid%3Dc7365c2b254eac06%26p1%3D4" id="bd_tousu">投诉快照</a>。</div>

    <div id="bd_snap_note">(百度和网页<a href="http://www.chinaunix.net/jh/25/48248.html">http://www.chinaunix.net/jh/25/48248.html</a>的作者无关，不对其内容负责。百度快照谨为网络故障时之索引，不代表被搜索网站的即时页面。)</div>
</div>
<div id="bd_snap_search">
	<form action="http://www.baidu.com/s"><input name="cl" value="3" type="hidden"><input value="" name="wd" id="bd_snap_kw" maxlength="100"><span id="bd_snap_btn_wr"><input id="bd_snap_su" value="百度一下" class="bd_snap_btn" onmousedown="this.className='bd_snap_btn bd_snap_btn_h'" type="submit"></span></form>
</div>
<div id="bd_snap_ln"></div>
<div style="position: relative;">


<title>[精华] 网络socket编程指南 - ChinaUnix.net</title>

<meta name="keywords" content="Linux,Freebsd,Solaris,Sco,HP-UX,IBM-AIX,cisco,oracle,java,cgi,mysql,perl,Apache,proFTP,Sendmail,Qmail,DNS,Squid,Rsync,SSL"> 
<meta name="description" content="ChinaUnix.net">





<center>

<!--导航start-->
<table border="0" cellpadding="0" cellspacing="0" width="760">
<tbody><tr><td>

</td></tr>
</tbody></table>
<!--导航end-->
<!--头部结束-->

<!--通栏广告开始-->
<table border="0" cellpadding="0" cellspacing="0" width="760">
<tbody><tr><td height="2"></td></tr>
<tr><td>

</td></tr>
</tbody></table>
<!--通栏广告结束-->

<table border="0" cellpadding="0" cellspacing="0" height="30" width="760">
<tbody><tr><td align="left" valign="middle">
<font color="#0000ff"><a href="http://www.chinaunix.net/" class="a02">ChinaUnix首页</a> &gt; 
<a href="http://www.chinaunix.net/jh" class="a02">精华文章</a> &gt; 
<a href="http://www.chinaunix.net/jh/25" class="a02">Perl</a> &gt; 正文</font>
</td>
<form name="_search" action="http://search.chinaunix.net/cgi-bin/search" method="post&quot;"></form>
<td align="right" valign="middle">
<input name="key" size="20" value="" class="t2" type="text"> <input name="enter" value="搜索" type="submit">
</td>

</tr>
</tbody></table>
<table border="0" cellpadding="0" cellspacing="0" width="760">
<tbody><tr><td height="3"></td></tr>
<tr><td bgcolor="#747474" height="1"><img src="c.gif" height="1" width="1"></td></tr>
</tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="760">
<tbody><tr><td rowspan="2" align="center" bgcolor="#EDF0F5" valign="top">
<br>
	<table border="0" cellpadding="0" cellspacing="0" width="90%">
	<tbody><tr><th class="f24"><font color="#05006C"><h1>[精华] 网络<a name="baidusnap0"></a><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>编程指南</h1></font></th></tr>
	<tr><td height=""><hr bgcolor="#d9d9d9" size="1"></td></tr>
	<tr><td align="center" height="20"> http://www.chinaunix.net 作者:<a href="http://bbs.chinaunix.net/viewpro.php?uid=366" target="_top">流浪者</a>&nbsp;&nbsp;发表于：2008-04-20 15:21:55</td></tr>
	<tr><td align="center" height="30">
【<a href="http://bbs.chinaunix.net/post.php?action=reply&amp;fid=25&amp;tid=48248" target="_top">发表评论</a>】
【<a href="http://bbs.chinaunix.net/viewthread.php?tid=48248" target="_top">查看原文</a>】
【<a href="http://bbs.chinaunix.net/forumdisplay.php?fid=25">Perl讨论区</a>】【<a href="javascript:window.close()">关闭</a>】
	</td></tr>
	<tr><td class="l17"><font id="zoom" class="f14">
<!-- 正文begin -->
	<table style="table-layout: fixed; word-wrap: break-word;" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td>
<br>
Beej网络<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>编程指南
<br>--------------------------------------------------------------------------------
<br>介绍
<br>　　<b style="color: black; background-color: rgb(255, 255, 102);">Socket</b>&nbsp;编程让你沮丧吗？从man&nbsp;pages中很难得到有用<a name="baidusnap2"></a><b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息吗？你想跟上时代去编Internet相关<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序，但是为你在调用&nbsp;connect()&nbsp;前<b style="color: black; background-color: rgb(153, 255, 153);">的</b>bind()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>结构而不知所措？等等…&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;好在我已经将这些事完成了，我将和所有人共享我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>知识了。如果你了解&nbsp;C&nbsp;语言并想穿过网络编程<b style="color: black; background-color: rgb(153, 255, 153);">的</b>沼泽，那么你来对地方了。
<br>--------------------------------------------------------------------------------
<br>读者对象&nbsp;
<br>　　这个文档是一个指南，而不是参考书。如果你刚开始&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>&nbsp;编程并想找一本入门书，那么你是我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>读者。但这不是一本完全<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>&nbsp;编程书。
<br>--------------------------------------------------------------------------------
<br>平台和编译器&nbsp;
<br>　　这篇文档中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>大多数代码都在&nbsp;Linux&nbsp;平台PC&nbsp;上用&nbsp;GNU&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;gcc&nbsp;成功编译过。而且它们在&nbsp;HPUX平台&nbsp;上用&nbsp;gcc&nbsp;也成功编译过。但是注意，并不是每个代码片段都独立测试过。
<br>--------------------------------------------------------------------------------
<br>目录：
<br>1)&nbsp;什么是套接字？&nbsp;
<br>2)&nbsp;Internet&nbsp;套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>两种类型&nbsp;
<br>3)&nbsp;网络理论&nbsp;
<br>4)&nbsp;结构体
<br>5)&nbsp;本机转换
<br>6)&nbsp;IP&nbsp;地址和如何处理它们&nbsp;
<br>7)&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()函数
<br>8)&nbsp;bind()函数
<br>9)&nbsp;connect()函数
<br>10)&nbsp;listen()函数
<br>11)&nbsp;accept()函数
<br>12)&nbsp;send()和recv()函数
<br>13)&nbsp;sendto()和recvfrom()函数
<br>14)&nbsp;close()和shutdown()函数
<br>15)&nbsp;getpeername()函数
<br>16)&nbsp;gethostname()函数
<br>17)&nbsp;域名服务（DNS）
<br>18)&nbsp;客户-服务器背景知识&nbsp;
<br>19)&nbsp;简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>服务器
<br>20)&nbsp;简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>客户端
<br>21)&nbsp;数据报套接字<b style="color: black; background-color: rgb(255, 255, 102);">Socket</b>
<br>22)&nbsp;阻塞
<br>23)&nbsp;select()--多路同步I/O
<br>24)&nbsp;参考资料&nbsp;
<br>--------------------------------------------------------------------------------
<br>什么是&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>？&nbsp;
<br>　　你经常听到人们谈论着&nbsp;“<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>”，或许你还不知道它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>确切含义。现在让我告诉你：它是<a name="baidusnap3"></a><b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;标准Unix&nbsp;文件描述符&nbsp;(file&nbsp;descriptor)&nbsp;和其它程序通讯<b style="color: black; background-color: rgb(153, 255, 153);">的</b>方式。什么？你也许听到一些Unix高手(hacker)这样说过：“呀，Unix中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一切就是文件！”那个家伙也许正在说到一个事实：Unix&nbsp;程序在执行任何形式<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;I/O&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，程序是在读或者写一个文件描述符。一个文件描述符只是一个和打开<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件相关联<b style="color: black; background-color: rgb(153, 255, 153);">的</b>整数。但是(注意后面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话)，这个文件可能是一个网络连接，FIFO，管道，终端，磁盘上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件或者什么其它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>东西。Unix&nbsp;中所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>东西就是文件！所以，你想和Internet上别<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序通讯<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，你将要<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>到文件描述符。你必须理解刚才<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话。现在你脑海中或许冒出这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>念头：“那么我从哪里得到网络通讯<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符呢？”，这个问题无论如何我都要回答：你利用系统调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()，它返回套接字描述符&nbsp;(<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>&nbsp;descriptor)，然后你再通过它来进行send()&nbsp;和&nbsp;recv()调用。“但是...”，你可能有很大<b style="color: black; background-color: rgb(153, 255, 153);">的</b>疑惑，“如果它是个文件描述符，那么为什&nbsp;么不用一般调用read()和write()来进行套接字通讯？”简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>答案是：“你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>！”。详细<b style="color: black; background-color: rgb(153, 255, 153);">的</b>答案是：“你可以，但是<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>send()和recv()让你更好<b style="color: black; background-color: rgb(153, 255, 153);">的</b>控制数据传输。”存在这样一个情况：在我们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>世界上，有很多种套接字。有DARPA&nbsp;Internet&nbsp;地址&nbsp;(Internet&nbsp;套接字)，本地节点<b style="color: black; background-color: rgb(153, 255, 153);">的</b>路径名&nbsp;(Unix套接字)，CCITT&nbsp;X.25地址&nbsp;(你可以将X.25&nbsp;套接字完全忽略)。也许在你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>Unix&nbsp;机器上还有其它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。我们在这里只讲第一种：Internet&nbsp;套接字。
<br>--------------------------------------------------------------------------------
<br>Internet&nbsp;套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>两种类型&nbsp;
<br>　　什么意思？有两种类型<b style="color: black; background-color: rgb(153, 255, 153);">的</b>Internet&nbsp;套接字？是<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。不，我在撒谎。其实还有很多，但是我可不想吓着你。我们这里只讲两种。除了这些,&nbsp;我打算另外介绍<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;"Raw&nbsp;Sockets"&nbsp;也是非常强大<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，很值得查阅。
<br>那么这两种类型是什么呢？一种是"Stream&nbsp;Sockets"（流格式），另外一种是"Datagram&nbsp;Sockets"（数据包格式）。我们以后谈到它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候也会用到&nbsp;"SOCK_STREAM"&nbsp;和&nbsp;"SOCK_DGRAM"。数据报套接字有时也叫“无连接套接字”(如果你确实要连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候可以用connect()。)&nbsp;流式套接字是可靠<b style="color: black; background-color: rgb(153, 255, 153);">的</b>双向通讯<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据流。如果你向套接字按顺序输出“1，2”，那么它们将按顺序“1，2”到达另一边。它们是无错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>传递<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，有自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>错误控制，在此不讨论。
<br>&nbsp;&nbsp;&nbsp;&nbsp;有什么在<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>流式套接字？你可能听说过&nbsp;telnet，不是吗？它就<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>流式套接字。你需要你所输入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符按顺序到达，不是吗？同样，WWW浏览器<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;HTTP&nbsp;协议也<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>它们来下载页面。实际上，当你通过端口80&nbsp;telnet&nbsp;到一个&nbsp;WWW&nbsp;站点，然后输入&nbsp;“GET&nbsp;pagename”&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，你也可以得到&nbsp;HTML&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>内容。为什么流式套接字可以达到高质量<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据传输？这是因为它<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>了“传输控制协议&nbsp;(The&nbsp;Transmission&nbsp;Control&nbsp;Protocol)”，也叫&nbsp;“TCP”&nbsp;(请参考&nbsp;RFC-793&nbsp;获得详细资料。)TCP&nbsp;控制你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据按顺序到达并且没有错
<br>误。你也许听到&nbsp;“TCP”&nbsp;是因为听到过&nbsp;“TCP/IP”。这里<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;是指“Internet&nbsp;协议”(请参考&nbsp;RFC-791。)&nbsp;IP&nbsp;只是处理&nbsp;Internet&nbsp;路由而已。&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;那么数据报套接字呢？为什么它叫无连接呢？为什么它是不可靠<b style="color: black; background-color: rgb(153, 255, 153);">的</b>呢？有这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一些事实：如果你发送一个数据报，它可能会到达，它可能次序颠倒了。如果它到达，那么在这个包<b style="color: black; background-color: rgb(153, 255, 153);">的</b>内部是无错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。数据报也<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;IP&nbsp;作路由，但是它不<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;TCP。它<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>“用户数据报协议&nbsp;(User&nbsp;Datagram&nbsp;Protocol)”，也叫&nbsp;“UDP”&nbsp;(请参考&nbsp;RFC-768。)&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么它们是无连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>呢？主要是因为它并不象流式套接字那样维持一个连接。你只要建立一个包，构造一个有目标信息<b style="color: black; background-color: rgb(153, 255, 153);">的</b>IP&nbsp;头，然后发出去。无需连接。它们通常<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>于传输包-包信息。简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>应用程序有：tftp,&nbsp;bootp等等。
<br>&nbsp;&nbsp;&nbsp;&nbsp;你也许会想：“假如数据丢失了这些程序如何正常工作？”我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>朋友，每个程序在&nbsp;UDP&nbsp;上有自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>协议。例如，tftp&nbsp;协议每发出<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一个被接受到包，收到者必须发回一个包来说“我收到了！”&nbsp;(一个“命令正确应答”也叫“ACK”&nbsp;包)。如果在一定时间内(例如5秒)，发送方没有收到应答，它将重新发送，直到得到&nbsp;ACK。这一ACK过程在实现&nbsp;SOCK_DGRAM&nbsp;应用程序<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候非常重要。
<br>--------------------------------------------------------------------------------
<br>网络理论
<br>　　既然我刚才提到了协议层，那么现在是讨论网络究竟如何工作和一些&nbsp;关于&nbsp;SOCK_DGRAM&nbsp;包是如何建立<b style="color: black; background-color: rgb(153, 255, 153);">的</b>例子。当然，你也可以跳过这一段，&nbsp;如果你认为已经熟悉<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话。&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;现在是学习数据封装&nbsp;(Data&nbsp;Encapsulation)&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候了！它非常非常重&nbsp;要。它重要性重要到你在网络课程学（图1：数据封装）习中无论如何也得也得掌握它。主要&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>内容是：一个包，先是被第一个协议(在这里是TFTP&nbsp;)在它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>报头（也许&nbsp;是报尾）包装(“封装”)，然后，整个数据(包括&nbsp;TFTP&nbsp;头)被另外一个协议&nbsp;(在这里是&nbsp;UDP&nbsp;)封装，然后下一个(&nbsp;IP&nbsp;)，一直重复下去，直到硬件(物理)&nbsp;层(&nbsp;这里是以太网&nbsp;)。&nbsp;
<br>当另外一台机器接收到包，硬件先剥去以太网头，内核剥去IP和UDP&nbsp;头，TFTP程序再剥去TFTP头，最后得到数据。现在我们终于讲到声名狼藉<b style="color: black; background-color: rgb(153, 255, 153);">的</b>网络分层模型&nbsp;(Layered&nbsp;Network&nbsp;Model)。这种网络模型在描述网络系统上相对其它模型有很多优点。例如，&nbsp;你可以写一个套接字程序而不用关心数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>物理传输(串行口，以太网，连&nbsp;接单元接口&nbsp;(AUI)&nbsp;还是其它介质)，因为底层<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序会为你处理它们。实际&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>网络硬件和拓扑对于程序员来说是透明<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。
<br>不说其它废话了，我现在列出整个层次模型。如果你要参加网络考试，&nbsp;可一定要记住：&nbsp;
<br>应用层&nbsp;(Application)
<br>表示层&nbsp;(Presentation)
<br>会话层&nbsp;(Session)
<br>传输层(Transport)
<br>网络层(Network)
<br>数据链路层(Data&nbsp;Link)
<br>物理层(Physical)
<br>物理层是硬件(串口，以太网等等)。应用层是和硬件层相隔最远<b style="color: black; background-color: rgb(153, 255, 153);">的</b>--它&nbsp;是用户和网络交互<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地方。&nbsp;
<br>这个模型如此通用，如果你想，你可以把它作为修车指南。把它对应&nbsp;到&nbsp;Unix，结果是：
<br>应用层(Application&nbsp;Layer)&nbsp;(telnet,&nbsp;ftp,等等)
<br>传输层(Host-to-Host&nbsp;Transport&nbsp;Layer)&nbsp;(TCP,&nbsp;UDP)
<br>Internet层(Internet&nbsp;Layer)&nbsp;(IP和路由)
<br>网络访问层&nbsp;(Network&nbsp;Access&nbsp;Layer)&nbsp;(网络层，数据链路层和物理层)
<br>现在，你可能看到这些层次如何协调来封装原始<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据了。&nbsp;
<br>看看建立一个简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据包有多少工作？哎呀，你将不得不<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;"cat"&nbsp;来建立数据包头！这仅仅是个玩笑。对于流式套接字你要作<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是&nbsp;send()&nbsp;发&nbsp;送数据。对于数据报式套接字，你按照你选择<b style="color: black; background-color: rgb(153, 255, 153);">的</b>方式封装数据然后<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;sendto()。内核将为你建立传输层和&nbsp;Internet&nbsp;层，硬件完成网络访问层。&nbsp;这就是现代科技。&nbsp;
<br>现在结束我们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>网络理论速成班。哦，忘记告诉你关于路由<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事情了。&nbsp;但是我不准备谈它，如果你真<b style="color: black; background-color: rgb(153, 255, 153);">的</b>关心，那么参考&nbsp;IP&nbsp;RFC。
<br>--------------------------------------------------------------------------------
<br>结构体&nbsp;
<br>　　终于谈到编程了。在这章，我将谈到被套接字用到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>各种数据类型。&nbsp;因为它们中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一些内容很重要了。&nbsp;
<br>首先是简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一个：<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>描述符。它是下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>类型：&nbsp;
<br>int&nbsp;
<br>仅仅是一个常见<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;int。&nbsp;
<br>从现在起，事情变得不可思议了，而你所需做<b style="color: black; background-color: rgb(153, 255, 153);">的</b>就是继续看下去。注&nbsp;意这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事实：有两种字节排列顺序：重要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节&nbsp;(有时叫&nbsp;"octet"，即八&nbsp;位位组)&nbsp;在前面，或者不重要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节在前面。前一种叫“网络字节顺序&nbsp;(Network&nbsp;Byte&nbsp;Order)”。有些机器在内部是按照这个顺序储存数据，而另外&nbsp;一些则不然。当我说某数据必须按照&nbsp;NBO&nbsp;顺序，那么你要调用函数(例如&nbsp;htons()&nbsp;)来将它从本机字节顺序&nbsp;(Host&nbsp;Byte&nbsp;Order)&nbsp;转换过来。如果我没有&nbsp;提到&nbsp;NBO，&nbsp;那么就让它保持本机字节顺序。
<br>我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>第一个结构(在这个技术手册TM中)--struct&nbsp;sockaddr.。这个结构&nbsp;为许多类型<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字储存套接字地址信息：&nbsp;
<br>struct&nbsp;sockaddr&nbsp;{&nbsp;
<br>　　&nbsp;unsigned&nbsp;short&nbsp;sa_family;&nbsp;/*&nbsp;地址家族,&nbsp;AF_xxx&nbsp;*/&nbsp;
<br>　　&nbsp;char&nbsp;sa_data[14];&nbsp;/*14字节协议地址*/&nbsp;
<br>　　&nbsp;};&nbsp;
<br>sa_family&nbsp;能够是各种各样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>类型，但是在这篇文章中都是&nbsp;"AF_INET"。&nbsp;sa_data包含套接字中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>目标地址和端口信息。这好像有点&nbsp;不明智。&nbsp;
<br>为了处理struct&nbsp;sockaddr，程序员创造了一个并列<b style="color: black; background-color: rgb(153, 255, 153);">的</b>结构：&nbsp;struct&nbsp;sockaddr_in&nbsp;("in"&nbsp;代表&nbsp;"Internet"。)
<br>struct&nbsp;sockaddr_in&nbsp;{&nbsp;
<br>　　&nbsp;short&nbsp;int&nbsp;sin_family;&nbsp;/*&nbsp;通信类型&nbsp;*/&nbsp;
<br>　　&nbsp;unsigned&nbsp;short&nbsp;int&nbsp;sin_port;&nbsp;/*&nbsp;端口&nbsp;*/&nbsp;
<br>　　&nbsp;struct&nbsp;in_addr&nbsp;sin_addr;&nbsp;/*&nbsp;Internet&nbsp;地址&nbsp;*/&nbsp;
<br>　　&nbsp;unsigned&nbsp;char&nbsp;sin_zero[8];&nbsp;/*&nbsp;与sockaddr结构<b style="color: black; background-color: rgb(153, 255, 153);">的</b>长度相同*/&nbsp;
<br>　　&nbsp;};&nbsp;
<br>用这个数据结构可以轻松处理套接字地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>基本元素。注意&nbsp;sin_zero&nbsp;(它被加入到这个结构，并且长度和&nbsp;struct&nbsp;sockaddr&nbsp;一样)&nbsp;应该<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>函数&nbsp;bzero()&nbsp;或&nbsp;memset()&nbsp;来全部置零。&nbsp;同时，这一重要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节，一个指向&nbsp;sockaddr_in结构体<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针也可以被指向结构体sockaddr并且代替它。这&nbsp;样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话即使&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;想要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是&nbsp;struct&nbsp;sockaddr&nbsp;*，你仍然可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;struct&nbsp;sockaddr_in，并且在最后转换。同时，注意&nbsp;sin_family&nbsp;和&nbsp;struct&nbsp;sockaddr&nbsp;中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;sa_family&nbsp;一致并能够设置为&nbsp;"AF_INET"。最后，sin_port和&nbsp;sin_addr&nbsp;必须是网络字节顺序&nbsp;(Network&nbsp;Byte&nbsp;Order)！
<br>你也许会反对道："但是，怎么让整个数据结构&nbsp;struct&nbsp;in_addr&nbsp;sin_addr&nbsp;按照网络字节顺序呢?"&nbsp;要知道这个问题<b style="color: black; background-color: rgb(153, 255, 153);">的</b>答案，我们就要仔细<b style="color: black; background-color: rgb(153, 255, 153);">的</b>看一看这&nbsp;个数据结构：&nbsp;struct&nbsp;in_addr,&nbsp;有这样一个联合&nbsp;(unions)：&nbsp;
<br>/*&nbsp;Internet&nbsp;地址&nbsp;(一个与历史有关<b style="color: black; background-color: rgb(153, 255, 153);">的</b>结构)&nbsp;*/&nbsp;
<br>　　&nbsp;struct&nbsp;in_addr&nbsp;{&nbsp;
<br>　　&nbsp;unsigned&nbsp;long&nbsp;s_addr;&nbsp;
<br>　　&nbsp;};&nbsp;
<br>它曾经是个最坏<b style="color: black; background-color: rgb(153, 255, 153);">的</b>联合，但是现在那些日子过去了。如果你声明&nbsp;"ina"&nbsp;是数据结构&nbsp;struct&nbsp;sockaddr_in&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>实例，那么&nbsp;"ina.sin_addr.s_addr"&nbsp;就储&nbsp;存4字节<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址(<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>网络字节顺序)。如果你不幸<b style="color: black; background-color: rgb(153, 255, 153);">的</b>系统<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>还是恐&nbsp;怖<b style="color: black; background-color: rgb(153, 255, 153);">的</b>联合&nbsp;struct&nbsp;in_addr&nbsp;，你还是可以放心4字节<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址并且和上面&nbsp;我说<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一样(这是因为<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>了“#define”。)&nbsp;
<br>--------------------------------------------------------------------------------
<br>本机转换
<br>　　我们现在到了新<b style="color: black; background-color: rgb(153, 255, 153);">的</b>章节。我们曾经讲了很多网络到本机字节顺序<b style="color: black; background-color: rgb(153, 255, 153);">的</b>转&nbsp;换，现在可以实践了！&nbsp;
<br>你能够转换两种类型：&nbsp;short&nbsp;(两个字节)和&nbsp;long&nbsp;(四个字节)。这个函&nbsp;数对于变量类型&nbsp;unsigned&nbsp;也适用。假设你想将&nbsp;short&nbsp;从本机字节顺序转&nbsp;换为网络字节顺序。用&nbsp;"h"&nbsp;表示&nbsp;"本机&nbsp;(host)"，接着是&nbsp;"to"，然后用&nbsp;"n"&nbsp;表&nbsp;示&nbsp;"网络&nbsp;(network)"，最后用&nbsp;"s"&nbsp;表示&nbsp;"short"：&nbsp;h-to-n-s,&nbsp;或者&nbsp;htons()&nbsp;("Host&nbsp;to&nbsp;Network&nbsp;Short")。
<br>太简单了...&nbsp;
<br>如果不是太傻<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话，你一定想到了由"n"，"h"，"s"，和&nbsp;"l"形成<b style="color: black; background-color: rgb(153, 255, 153);">的</b>正确&nbsp;组合，例如这里肯定没有stolh()&nbsp;("Short&nbsp;to&nbsp;Long&nbsp;Host")&nbsp;函数，不仅在这里&nbsp;没有，所有场合都没有。但是这里有：
<br>htons()--"Host&nbsp;to&nbsp;Network&nbsp;Short"
<br>　　htonl()--"Host&nbsp;to&nbsp;Network&nbsp;Long"
<br>　　ntohs()--"Network&nbsp;to&nbsp;Host&nbsp;Short"
<br>　　ntohl()--"Network&nbsp;to&nbsp;Host&nbsp;Long"
<br>现在，你可能想你已经知道它们了。你也可能想：“如果我想改变&nbsp;char&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>顺序要怎么办呢?”&nbsp;但是你也许马上就想到，“用不着考虑<b style="color: black; background-color: rgb(153, 255, 153);">的</b>”。你也许&nbsp;会想到：我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;68000&nbsp;机器已经<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>了网络字节顺序，我没有必要去调用&nbsp;htonl()&nbsp;转换&nbsp;IP&nbsp;地址。你可能是对<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，但是当你移植你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序到别<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器&nbsp;上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序将失败。可移植性！这里是&nbsp;Unix&nbsp;世界！记住：在你&nbsp;将数据放到网络上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，确信它们是网络字节顺序<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。&nbsp;
<br>最后一点：为什么在数据结构&nbsp;struct&nbsp;sockaddr_in&nbsp;中，&nbsp;sin_addr&nbsp;和&nbsp;sin_port&nbsp;需要转换为网络字节顺序，而sin_family&nbsp;需不需要呢?&nbsp;答案是：&nbsp;sin_addr&nbsp;和&nbsp;sin_port&nbsp;分别封装在包<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;和&nbsp;UDP&nbsp;层。因此，它们必须要&nbsp;是网络字节顺序。但是&nbsp;sin_family&nbsp;域只是被内核&nbsp;(kernel)&nbsp;<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>来决定在数&nbsp;据结构中包含什么类型<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址，所以它必须是本机字节顺序。同时，&nbsp;sin_family&nbsp;没有发送到网络上，它们可以是本机字节顺序。&nbsp;
<br>--------------------------------------------------------------------------------
<br>IP&nbsp;地址和如何处理它们
<br>现在我们很幸运，因为我们有很多<b style="color: black; background-color: rgb(153, 255, 153);">的</b>函数来方便地操作&nbsp;IP&nbsp;地址。没有&nbsp;必要用手工计算它们，也没有必要用"&lt;&lt;"操作来储存成长整字型。&nbsp;首先，假设你已经有了一个sockaddr_in结构体ina，你有一个IP地&nbsp;址"132.241.5.10"要储存在其中，你就要用到函数inet_addr(),将IP地址从&nbsp;点数格式转换成无符号长整型。<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>方法如下：
<br>ina.sin_addr.s_addr&nbsp;=&nbsp;inet_addr("132.241.5.10");
<br>注意，inet_addr()返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址已经是网络字节格式，所以你无需再调用&nbsp;函数htonl()。
<br>我们现在发现上面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码片断不是十分完整<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，因为它没有错误检查。&nbsp;显而易见，当inet_addr()发生错误时返回-1。记住这些二进制数字？(无符&nbsp;号数)-1仅仅和IP地址255.255.255.255相符合！这可是广播地址！大错特&nbsp;错！记住要先进行错误检查。
<br>好了，现在你可以将IP地址转换成长整型了。有没有其相反<b style="color: black; background-color: rgb(153, 255, 153);">的</b>方法呢？&nbsp;它可以将一个in_addr结构体输出成点数格式？这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话，你就要用到函数&nbsp;inet_ntoa()("ntoa"<b style="color: black; background-color: rgb(153, 255, 153);">的</b>含义是"network&nbsp;to&nbsp;ascii")，就像这样：&nbsp;
<br>printf("%s",inet_ntoa(ina.sin_addr));
<br>它将输出IP地址。需要注意<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是inet_ntoa()将结构体in-addr作为一&nbsp;个参数，不是长整形。同样需要注意<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是它返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是一个指向一个字符<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;指针。它是一个由inet_ntoa()控制<b style="color: black; background-color: rgb(153, 255, 153);">的</b>静态<b style="color: black; background-color: rgb(153, 255, 153);">的</b>固定<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，所以每次调用&nbsp;inet_ntoa()，它就将覆盖上次调用时所得<b style="color: black; background-color: rgb(153, 255, 153);">的</b>IP地址。例如：
<br>char&nbsp;*a1,&nbsp;*a2;
<br>.
<br>.
<br>a1&nbsp;=&nbsp;inet_ntoa(ina1.sin_addr);&nbsp;/*&nbsp;这是198.92.129.1&nbsp;*/
<br>a2&nbsp;=&nbsp;inet_ntoa(ina2.sin_addr);&nbsp;/*&nbsp;这是132.241.5.10&nbsp;*/
<br>printf("address&nbsp;1:&nbsp;%s\n",a1);
<br>printf("address&nbsp;2:&nbsp;%s\n",a2);
<br>输出如下：
<br>address&nbsp;1:&nbsp;132.241.5.10
<br>address&nbsp;2:&nbsp;132.241.5.10
<br>假如你需要保存这个IP地址，<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>strcopy()函数来指向你自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符&nbsp;指针。
<br>上面就是关于这个主题<b style="color: black; background-color: rgb(153, 255, 153);">的</b>介绍。稍后，你将学习将一个类&nbsp;似"wintehouse.gov"<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符串转换成它所对应<b style="color: black; background-color: rgb(153, 255, 153);">的</b>IP地址(查阅域名服务,稍&nbsp;后)。
<br>--------------------------------------------------------------------------------
<br><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()函数&nbsp;
<br>我想我不能再不提这个了－下面我将讨论一下<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()系统调用。
<br>下面是详细介绍：
<br>#include&nbsp;&lt;sys/types.h&gt;;&nbsp;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;&nbsp;
<br>int&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(int&nbsp;domain,&nbsp;int&nbsp;type,&nbsp;int&nbsp;protocol);&nbsp;
<br>但是它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>参数是什么?&nbsp;首先，domain&nbsp;应该设置成&nbsp;"AF_INET"，就&nbsp;象上面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构struct&nbsp;sockaddr_in&nbsp;中一样。然后，参数&nbsp;type&nbsp;告诉内核&nbsp;是&nbsp;SOCK_STREAM&nbsp;类型还是&nbsp;SOCK_DGRAM&nbsp;类型。最后，把&nbsp;protocol&nbsp;设置为&nbsp;"0"。(注意：有很多种&nbsp;domain、type，我不可能一一列出了，请看&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man帮助。当然，还有一个"更好"<b style="color: black; background-color: rgb(153, 255, 153);">的</b>方式去得到&nbsp;protocol。同&nbsp;时请查阅&nbsp;getprotobyname()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;帮助。)&nbsp;
<br><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;只是返回你以后在系统调用种可能用到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>&nbsp;描述符，或&nbsp;者在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回-1。全局变量&nbsp;errno&nbsp;中将储存返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>错误值。(请参考&nbsp;perror()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;帮助。)&nbsp;
<br>--------------------------------------------------------------------------------
<br>bind()函数
<br>　　一旦你有一个套接字，你可能要将套接字和机器上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一定<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口关联&nbsp;起来。(如果你想用listen()来侦听一定端口<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据，这是必要一步--MUD&nbsp;告&nbsp;诉你说用命令&nbsp;"telnet&nbsp;x.y.z&nbsp;6969"。)如果你只想用&nbsp;connect()，那么这个步&nbsp;骤没有必要。但是无论如何，请继续读下去。
<br>这里是系统调用&nbsp;bind()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>大概：
<br>#include&nbsp;&lt;sys/types.h&gt;;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>int&nbsp;bind(int&nbsp;sockfd,&nbsp;struct&nbsp;sockaddr&nbsp;*my_addr,&nbsp;int&nbsp;addrlen);&nbsp;
<br>sockfd&nbsp;是调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符。my_addr&nbsp;是指向数据结构&nbsp;struct&nbsp;sockaddr&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，它保存你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址(即端口和&nbsp;IP&nbsp;地址)&nbsp;信息。&nbsp;addrlen&nbsp;设置为&nbsp;sizeof(struct&nbsp;sockaddr)。&nbsp;
<br>简单得很不是吗?&nbsp;再看看例子：&nbsp;
<br>#include&nbsp;&lt;string.h&gt;;
<br>#include&nbsp;&lt;sys/types.h&gt;;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>#define&nbsp;MYPORT&nbsp;3490&nbsp;
<br>main()
<br>　　&nbsp;{
<br>　　&nbsp;int&nbsp;sockfd;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;my_addr;
<br>sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);&nbsp;/*需要错误检查&nbsp;*/
<br>my_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_port&nbsp;=&nbsp;htons(MYPORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_addr.s_addr&nbsp;=&nbsp;inet_addr("132.241.5.10");&nbsp;
<br>　　&nbsp;bzero(&amp;amp;(my_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>/*&nbsp;don't&nbsp;forget&nbsp;your&nbsp;error&nbsp;checking&nbsp;for&nbsp;bind():&nbsp;*/&nbsp;
<br>　　&nbsp;bind(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;my_addr,&nbsp;sizeof(struct&nbsp;sockaddr));&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>这里也有要注意<b style="color: black; background-color: rgb(153, 255, 153);">的</b>几件事情。my_addr.sin_port&nbsp;是网络字节顺序，&nbsp;my_addr.sin_addr.s_addr&nbsp;也是<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。另外要注意到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事情是因系统<b style="color: black; background-color: rgb(153, 255, 153);">的</b>不同，&nbsp;包含<b style="color: black; background-color: rgb(153, 255, 153);">的</b>头文件也不尽相同，请查阅本地<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;帮助文件。
<br>在&nbsp;bind()&nbsp;主题中最后要说<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话是，在处理自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址和/或端口<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;时候，有些工作是可以自动处理<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。
<br>my_addr.sin_port&nbsp;=&nbsp;0;&nbsp;/*&nbsp;随机选择一个没有<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口&nbsp;*/&nbsp;
<br>　　my_addr.sin_addr.s_addr&nbsp;=&nbsp;INADDR_ANY;&nbsp;/*&nbsp;<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>IP地址&nbsp;*/&nbsp;
<br>通过将0赋给&nbsp;my_addr.sin_port，你告诉&nbsp;bind()&nbsp;自己选择合适<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端&nbsp;口。同样，将&nbsp;my_addr.sin_addr.s_addr&nbsp;设置为&nbsp;INADDR_ANY，你告诉&nbsp;它自动填上它所运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址。
<br>如果你一向小心谨慎，那么你可能注意到我没有将&nbsp;INADDR_ANY&nbsp;转&nbsp;换为网络字节顺序！这是因为我知道内部<b style="color: black; background-color: rgb(153, 255, 153);">的</b>东西：INADDR_ANY&nbsp;实际上就&nbsp;是&nbsp;0！即使你改变字节<b style="color: black; background-color: rgb(153, 255, 153);">的</b>顺序，0依然是0。但是完美主义者说应该处处一&nbsp;致，INADDR_ANY或许是12呢？你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码就不能工作了，那么就看下面&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码：
<br>my_addr.sin_port&nbsp;=&nbsp;htons(0);&nbsp;/*&nbsp;随机选择一个没有<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口&nbsp;*/&nbsp;
<br>my_addr.sin_addr.s_addr&nbsp;=&nbsp;htonl(INADDR_ANY);/*&nbsp;<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>自己<b style="color: black; background-color: rgb(153, 255, 153);">的</b>IP地址&nbsp;*/&nbsp;
<br>你或许不相信，上面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码将可以随便移植。我只是想指出，既然你&nbsp;所遇到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序不会都运行<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>htonl<b style="color: black; background-color: rgb(153, 255, 153);">的</b>INADDR_ANY。
<br>bind()&nbsp;在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候依然是返回-1，并且设置全局错误变量errno。&nbsp;
<br>在你调用&nbsp;bind()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，你要小心<b style="color: black; background-color: rgb(153, 255, 153);">的</b>另一件事情是：不要采用小于&nbsp;1024<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口号。所有小于1024<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口号都被系统保留！你可以选择从1024&nbsp;到65535<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口(如果它们没有被别<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>话)。
<br>你要注意<b style="color: black; background-color: rgb(153, 255, 153);">的</b>另外一件小事是：有时候你根本不需要调用它。如果你使&nbsp;用&nbsp;connect()&nbsp;来和远程机器进行通讯，你不需要关心你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>本地端口号(就象&nbsp;你在<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;telnet&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候)，你只要简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>调用&nbsp;connect()&nbsp;就可以了，它会检&nbsp;查套接字是否绑定端口，如果没有，它会自己绑定一个没有<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>本地端口。
<br>--------------------------------------------------------------------------------
<br>connect()程序
<br>　　现在我们假设你是个&nbsp;telnet&nbsp;程序。你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>用户命令你得到套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件&nbsp;描述符。你听从命令调用了<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()。下一步，你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>用户告诉你通过端口&nbsp;23(标准&nbsp;telnet&nbsp;端口)连接到"132.241.5.10"。你该怎么做呢?&nbsp;幸运<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是，你正在阅读&nbsp;connect()--如何连接到远程主机这一章。你可&nbsp;不想让你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>用户失望。&nbsp;
<br>connect()&nbsp;系统调用是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：&nbsp;
<br>#include&nbsp;&lt;sys/types.h&gt;;&nbsp;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>int&nbsp;connect(int&nbsp;sockfd,&nbsp;struct&nbsp;sockaddr&nbsp;*serv_addr,&nbsp;int&nbsp;addrlen);&nbsp;
<br>sockfd&nbsp;是系统调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字文件描述符。serv_addr&nbsp;是&nbsp;保存着目<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地端口和&nbsp;IP&nbsp;地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构&nbsp;struct&nbsp;sockaddr。addrlen&nbsp;设置&nbsp;为&nbsp;sizeof(struct&nbsp;sockaddr)。&nbsp;
<br>想知道得更多吗？让我们来看个例子：&nbsp;
<br>#include&nbsp;&lt;string.h&gt;;&nbsp;
<br>#include&nbsp;&lt;sys/types.h&gt;;&nbsp;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;&nbsp;
<br>#define&nbsp;DEST_IP&nbsp;"132.241.5.10"&nbsp;
<br>　　#define&nbsp;DEST_PORT&nbsp;23&nbsp;
<br>main()&nbsp;
<br>　　&nbsp;{&nbsp;
<br>int&nbsp;sockfd;&nbsp;
<br>struct&nbsp;sockaddr_in&nbsp;dest_addr;&nbsp;/*&nbsp;目<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址*/&nbsp;
<br>sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);&nbsp;/*&nbsp;错误检查&nbsp;*/&nbsp;
<br>dest_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>dest_addr.sin_port&nbsp;=&nbsp;htons(DEST_PORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>dest_addr.sin_addr.s_addr&nbsp;=&nbsp;inet_addr(DEST_IP);&nbsp;
<br>bzero(&amp;amp;(dest_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>/*&nbsp;don't&nbsp;forget&nbsp;to&nbsp;error&nbsp;check&nbsp;the&nbsp;connect()!&nbsp;*/&nbsp;
<br>connect(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;dest_addr,&nbsp;sizeof(struct&nbsp;sockaddr));&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　再一次，你应该检查&nbsp;connect()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>返回值--它在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回-1，并&nbsp;设置全局错误变量&nbsp;errno。&nbsp;
<br>同时，你可能看到，我没有调用&nbsp;bind()。因为我不在乎本地<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口号。&nbsp;我只关心我要去那。内核将为我选择一个合适<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口号，而我们所连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;地方也自动地获得这些信息。一切都不用担心。&nbsp;
<br>--------------------------------------------------------------------------------
<br>listen()函数
<br>　　是换换内容得时候了。假如你不希望与远程<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一个地址相连，或者说，&nbsp;仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处&nbsp;理过程分两步：首先，你听--listen()，然后，你接受--accept()&nbsp;(请看下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;内容)。
<br>除了要一点解释外，系统调用&nbsp;listen&nbsp;也相当简单。
<br>int&nbsp;listen(int&nbsp;sockfd,&nbsp;int&nbsp;backlog);&nbsp;
<br>sockfd&nbsp;是调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字文件描述符。backlog&nbsp;是在进入&nbsp;队列中允许<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接数目。什么意思呢?&nbsp;进入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接是在队列中一直等待直&nbsp;到你接受&nbsp;(accept()&nbsp;请看下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文章)连接。它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数目限制于队列<b style="color: black; background-color: rgb(153, 255, 153);">的</b>允许。&nbsp;大多数系统<b style="color: black; background-color: rgb(153, 255, 153);">的</b>允许数目是20，你也可以设置为5到10。
<br>和别<b style="color: black; background-color: rgb(153, 255, 153);">的</b>函数一样，在发生错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回-1，并设置全局错误变量&nbsp;errno。
<br>你可能想象到了，在你调用&nbsp;listen()&nbsp;前你或者要调用&nbsp;bind()&nbsp;或者让内&nbsp;核随便选择一个端口。如果你想侦听进入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接，那么系统调用<b style="color: black; background-color: rgb(153, 255, 153);">的</b>顺序可&nbsp;能是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：&nbsp;
<br><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>();&nbsp;
<br>　　bind();&nbsp;
<br>listen();&nbsp;
<br>　　/*&nbsp;accept()&nbsp;应该在这&nbsp;*/&nbsp;
<br>因为它相当<b style="color: black; background-color: rgb(153, 255, 153);">的</b>明了，我将在这里不给出例子了。(在&nbsp;accept()&nbsp;那一章<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;代码将更加完全。)真正麻烦<b style="color: black; background-color: rgb(153, 255, 153);">的</b>部分在&nbsp;accept()。&nbsp;
<br>--------------------------------------------------------------------------------
<br>accept()函数
<br>　　准备好了，系统调用&nbsp;accept()&nbsp;会有点古怪<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地方<b style="color: black; background-color: rgb(153, 255, 153);">的</b>！你可以想象发生&nbsp;这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事情：有人从很远<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地方通过一个你在侦听&nbsp;(listen())&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口连接&nbsp;(connect())&nbsp;到你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器。它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接将加入到等待接受&nbsp;(accept())&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>队列&nbsp;中。你调用&nbsp;accept()&nbsp;告诉它你有空闲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接。它将返回一个新<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字文&nbsp;件描述符！这样你就有两个套接字了，原来<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一个还在侦听你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>那个端口，&nbsp;新<b style="color: black; background-color: rgb(153, 255, 153);">的</b>在准备发送&nbsp;(send())&nbsp;和接收&nbsp;(&nbsp;recv())&nbsp;数据。这就是这个过程！
<br>函数是这样定义<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：&nbsp;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>int&nbsp;accept(int&nbsp;sockfd,&nbsp;void&nbsp;*addr,&nbsp;int&nbsp;*addrlen);&nbsp;
<br>sockfd&nbsp;相当简单，是和&nbsp;listen()&nbsp;中一样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字描述符。addr&nbsp;是个指&nbsp;向局部<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构&nbsp;sockaddr_in&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针。这是要求接入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息所要去<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地&nbsp;方（你可以测定那个地址在那个端口呼叫你）。在它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址传递给&nbsp;accept&nbsp;之&nbsp;前，addrlen&nbsp;是个局部<b style="color: black; background-color: rgb(153, 255, 153);">的</b>整形变量，设置为&nbsp;sizeof(struct&nbsp;sockaddr_in)。&nbsp;accept&nbsp;将不会将多余<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节给&nbsp;addr。如果你放入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>少些，那么它会通过改
<br>变&nbsp;addrlen&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>值反映出来。&nbsp;
<br>同样，在错误时返回-1，并设置全局错误变量&nbsp;errno。&nbsp;
<br>现在是你应该熟悉<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码片段。&nbsp;
<br>#include&nbsp;&lt;string.h&gt;;
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>#include&nbsp;&lt;sys/types.h&gt;;
<br>#define&nbsp;MYPORT&nbsp;3490&nbsp;/*用户接入端口*/&nbsp;
<br>#define&nbsp;BACKLOG&nbsp;10&nbsp;/*&nbsp;多少等待连接控制*/&nbsp;
<br>main()&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　int&nbsp;sockfd,&nbsp;new_fd;&nbsp;/*&nbsp;listen&nbsp;on&nbsp;sock_fd,&nbsp;new&nbsp;connection&nbsp;on&nbsp;new_fd&nbsp;*/&nbsp;
<br>　　struct&nbsp;sockaddr_in&nbsp;my_addr;&nbsp;/*&nbsp;地址信息&nbsp;*/&nbsp;
<br>　　struct&nbsp;sockaddr_in&nbsp;their_addr;&nbsp;/*&nbsp;connector's&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　int&nbsp;sin_size;&nbsp;
<br>sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);&nbsp;/*&nbsp;错误检查*/&nbsp;
<br>my_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　my_addr.sin_port&nbsp;=&nbsp;htons(MYPORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　my_addr.sin_addr.s_addr&nbsp;=&nbsp;INADDR_ANY;&nbsp;/*&nbsp;auto-fill&nbsp;with&nbsp;my&nbsp;IP&nbsp;*/&nbsp;
<br>　　bzero(&amp;amp;(my_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>/*&nbsp;don't&nbsp;forget&nbsp;your&nbsp;error&nbsp;checking&nbsp;for&nbsp;these&nbsp;calls:&nbsp;*/&nbsp;
<br>　　bind(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;my_addr,&nbsp;sizeof(struct&nbsp;sockaddr));&nbsp;
<br>listen(sockfd,&nbsp;BACKLOG);&nbsp;
<br>sin_size&nbsp;=&nbsp;sizeof(struct&nbsp;sockaddr_in);&nbsp;
<br>　　new_fd&nbsp;=&nbsp;accept(sockfd,&nbsp;&amp;amp;their_addr,&nbsp;&amp;amp;sin_size);&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>注意，在系统调用&nbsp;send()&nbsp;和&nbsp;recv()&nbsp;中你应该<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>新<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字描述符&nbsp;new_fd。如果你只想让一个连接进来，那么你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;close()&nbsp;去关闭原&nbsp;来<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符&nbsp;sockfd&nbsp;来避免同一个端口更多<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接。&nbsp;
<br>--------------------------------------------------------------------------------
<br>send()&nbsp;and&nbsp;recv()函数
<br>　　这两个函数用于流式套接字或者数据报套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>通讯。如果你喜欢使&nbsp;用无连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据报套接字，你应该看一看下面关于sendto()&nbsp;和&nbsp;recvfrom()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>章节。
<br>send()&nbsp;是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：
<br>int&nbsp;send(int&nbsp;sockfd,&nbsp;const&nbsp;void&nbsp;*msg,&nbsp;int&nbsp;len,&nbsp;int&nbsp;flags);&nbsp;
<br>sockfd&nbsp;是你想发送数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字描述符(或者是调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;或者是&nbsp;accept()&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。)msg&nbsp;是指向你想发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针。len&nbsp;是数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>长度。&nbsp;把&nbsp;flags&nbsp;设置为&nbsp;0&nbsp;就可以了。(详细<b style="color: black; background-color: rgb(153, 255, 153);">的</b>资料请看&nbsp;send()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;page)。&nbsp;
<br>这里是一些可能<b style="color: black; background-color: rgb(153, 255, 153);">的</b>例子：
<br>char&nbsp;*msg&nbsp;=&nbsp;"Beej&nbsp;was&nbsp;here!";&nbsp;
<br>　　int&nbsp;len,&nbsp;bytes_sent;
<br>　　.&nbsp;
<br>　　.&nbsp;
<br>　　len&nbsp;=&nbsp;strlen(msg);
<br>　　bytes_sent&nbsp;=&nbsp;send(sockfd,&nbsp;msg,&nbsp;len,&nbsp;0);
<br>　　.&nbsp;
<br>　　.&nbsp;
<br>　　.&nbsp;
<br>send()&nbsp;返回实际发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节数--它可能小于你要求发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数&nbsp;目！&nbsp;注意，有时候你告诉它要发送一堆数据可是它不能处理成功。它只是&nbsp;发送它可能发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据，然后希望你能够发送其它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据。记住，如果&nbsp;send()&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据和&nbsp;len&nbsp;不匹配，你就应该发送其它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据。但是这里也&nbsp;有个好消息：如果你要发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>包很小(小于大约&nbsp;1K)，它可能处理让数据一&nbsp;次发送完。最后要说得就是，它在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回-1，并设置&nbsp;errno。
<br>recv()&nbsp;函数很相似：
<br>int&nbsp;recv(int&nbsp;sockfd,&nbsp;void&nbsp;*buf,&nbsp;int&nbsp;len,&nbsp;unsigned&nbsp;int&nbsp;flags);
<br>sockfd&nbsp;是要读<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字描述符。buf&nbsp;是要读<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息<b style="color: black; background-color: rgb(153, 255, 153);">的</b>缓冲。len&nbsp;是缓&nbsp;冲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>最大长度。flags&nbsp;可以设置为0。(请参考recv()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;page。)&nbsp;recv()&nbsp;返回实际读入缓冲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节数。或者在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回-1，&nbsp;同时设置&nbsp;errno。
<br>很简单，不是吗?&nbsp;你现在可以在流式套接字上发送数据和接收数据了。&nbsp;你现在是&nbsp;Unix&nbsp;网络程序员了！
<br>--------------------------------------------------------------------------------
<br>sendto()&nbsp;和&nbsp;recvfrom()函数
<br>　　“这很不错啊”，你说，“但是你还没有讲无连接数据报套接字呢？”&nbsp;没问题，现在我们开始这个内容。
<br>既然数据报套接字不是连接到远程主机<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，那么在我们发送一个包之&nbsp;前需要什么信息呢?&nbsp;不错，是目标地址！看看下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：
<br>int&nbsp;sendto(int&nbsp;sockfd,&nbsp;const&nbsp;void&nbsp;*msg,&nbsp;int&nbsp;len,&nbsp;unsigned&nbsp;int&nbsp;flags,&nbsp;
<br>　　const&nbsp;struct&nbsp;sockaddr&nbsp;*to,&nbsp;int&nbsp;tolen);&nbsp;
<br>你已经看到了，除了另外<b style="color: black; background-color: rgb(153, 255, 153);">的</b>两个信息外，其余<b style="color: black; background-color: rgb(153, 255, 153);">的</b>和函数&nbsp;send()&nbsp;是一样&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。&nbsp;to&nbsp;是个指向数据结构&nbsp;struct&nbsp;sockaddr&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，它包含了目<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址和端口信息。tolen&nbsp;可以简单地设置为&nbsp;sizeof(struct&nbsp;sockaddr)。&nbsp;和函数&nbsp;send()&nbsp;类似，sendto()&nbsp;返回实际发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节数(它也可能小于&nbsp;你想要发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节数！)，或者在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回&nbsp;-1。
<br>相似<b style="color: black; background-color: rgb(153, 255, 153);">的</b>还有函数&nbsp;recv()&nbsp;和&nbsp;recvfrom()。recvfrom()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>定义是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：
<br>int&nbsp;recvfrom(int&nbsp;sockfd,&nbsp;void&nbsp;*buf,&nbsp;int&nbsp;len,&nbsp;unsigned&nbsp;int&nbsp;flags,&nbsp;　struct&nbsp;sockaddr&nbsp;*from,&nbsp;int&nbsp;*fromlen);
<br>又一次，除了两个增加<b style="color: black; background-color: rgb(153, 255, 153);">的</b>参数外，这个函数和&nbsp;recv()&nbsp;也是一样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。from&nbsp;是一个指向局部数据结构&nbsp;struct&nbsp;sockaddr&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>内容是源机器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址和端口信息。fromlen&nbsp;是个&nbsp;int&nbsp;型<b style="color: black; background-color: rgb(153, 255, 153);">的</b>局部指针，它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>初始值为&nbsp;sizeof(struct&nbsp;sockaddr)。函数调用返回后，fromlen&nbsp;保存着实际储存在&nbsp;from&nbsp;中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>长度。
<br>recvfrom()&nbsp;返回收到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节长度，或者在发生错误后返回&nbsp;-1。
<br>记住，如果你用&nbsp;connect()&nbsp;连接一个数据报套接字，你可以简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>调&nbsp;用&nbsp;send()&nbsp;和&nbsp;recv()&nbsp;来满足你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>要求。这个时候依然是数据报套接字，依&nbsp;然<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;UDP，系统套接字接口会为你自动加上了目标和源<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息。
<br>--------------------------------------------------------------------------------
<br>close()和shutdown()函数
<br>　　你已经整天都在发送&nbsp;(send())&nbsp;和接收&nbsp;(recv())&nbsp;数据了，现在你准备关&nbsp;闭你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字描述符了。这很简单，你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>一般<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;Unix&nbsp;文件描述符&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;close()&nbsp;函数：
<br>　　close(sockfd);
<br>它将防止套接字上更多<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>读写。任何在另一端读写套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>企&nbsp;图都将返回错误信息。
<br>如果你想在如何关闭套接字上有多一点<b style="color: black; background-color: rgb(153, 255, 153);">的</b>控制，你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>函数&nbsp;shutdown()。它允许你将一定方向上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>通讯或者双向<b style="color: black; background-color: rgb(153, 255, 153);">的</b>通讯(就象close()一&nbsp;样)关闭，你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>：
<br>int&nbsp;shutdown(int&nbsp;sockfd,&nbsp;int&nbsp;how);&nbsp;
<br>sockfd&nbsp;是你想要关闭<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字文件描述复。how&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>值是下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>其中之&nbsp;一：
<br>　　0&nbsp;–&nbsp;不允许接受
<br>　　1&nbsp;–&nbsp;不允许发送
<br>　　2&nbsp;–&nbsp;不允许发送和接受(和&nbsp;close()&nbsp;一样)
<br>shutdown()&nbsp;成功时返回&nbsp;0，失败时返回&nbsp;-1(同时设置&nbsp;errno。)&nbsp;如果在无连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据报套接字中<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>shutdown()，那么只不过是让&nbsp;send()&nbsp;和&nbsp;recv()&nbsp;不能<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>(记住你在数据报套接字中<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>了&nbsp;connect&nbsp;后&nbsp;是可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>)。
<br>--------------------------------------------------------------------------------
<br>getpeername()函数
<br>　　这个函数太简单了。
<br>它太简单了，以至我都不想单列一章。但是我还是这样做了。&nbsp;函数&nbsp;getpeername()&nbsp;告诉你在连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>流式套接字上谁在另外一边。函&nbsp;数是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：
<br>#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>int&nbsp;getpeername(int&nbsp;sockfd,&nbsp;struct&nbsp;sockaddr&nbsp;*addr,&nbsp;int&nbsp;*addrlen);
<br>sockfd&nbsp;是连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>流式套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>描述符。addr&nbsp;是一个指向结构&nbsp;struct&nbsp;sockaddr&nbsp;(或者是&nbsp;struct&nbsp;sockaddr_in)&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，它保存着连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>另一边<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;信息。addrlen&nbsp;是一个&nbsp;int&nbsp;型<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，它初始化为&nbsp;sizeof(struct&nbsp;sockaddr)。&nbsp;函数在错误<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候返回&nbsp;-1，设置相应<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;errno。
<br>一旦你获得它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址，你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;inet_ntoa()&nbsp;或者&nbsp;gethostbyaddr()&nbsp;来打印或者获得更多<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息。但是你不能得到它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>帐号。(如果它运行着愚&nbsp;蠢<b style="color: black; background-color: rgb(153, 255, 153);">的</b>守护进程，这是可能<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，但是它<b style="color: black; background-color: rgb(153, 255, 153);">的</b>讨论已经超出了本文<b style="color: black; background-color: rgb(153, 255, 153);">的</b>范围，请参&nbsp;考&nbsp;RFC-1413&nbsp;以获得更多<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息。)&nbsp;
<br>--------------------------------------------------------------------------------
<br>gethostname()函数
<br>　　甚至比&nbsp;getpeername()&nbsp;还简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>函数是&nbsp;gethostname()。它返回你程&nbsp;序所运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>主机名字。然后你可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;gethostbyname()&nbsp;以获得你&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;IP&nbsp;地址。
<br>　　下面是定义：
<br>　　#include&nbsp;&lt;unistd.h&gt;;
<br>int&nbsp;gethostname(char&nbsp;*hostname,&nbsp;size_t&nbsp;size);
<br>参数很简单：hostname&nbsp;是一个字符数组指针，它将在函数返回时保存
<br>主机名。size是hostname&nbsp;数组<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字节长度。
<br>函数调用成功时返回&nbsp;0，失败时返回&nbsp;-1，并设置&nbsp;errno。
<br>--------------------------------------------------------------------------------
<br>域名服务（DNS）
<br>　　如果你不知道&nbsp;DNS&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>意思，那么我告诉你，它代表域名服务(Domain&nbsp;Name&nbsp;Service)。它主要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>功能是：你给它一个容易记忆<b style="color: black; background-color: rgb(153, 255, 153);">的</b>某站点<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址，&nbsp;它给你&nbsp;IP&nbsp;地址(然后你就可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;bind(),&nbsp;connect(),&nbsp;sendto()&nbsp;或者其它&nbsp;函数)&nbsp;。当一个人输入：
<br>　　&nbsp;$&nbsp;telnet&nbsp;whitehouse.gov&nbsp;
<br>telnet&nbsp;能知道它将连接&nbsp;(connect())&nbsp;到&nbsp;"198.137.240.100"。&nbsp;
<br>但是这是如何工作<b style="color: black; background-color: rgb(153, 255, 153);">的</b>呢?&nbsp;你可以调用函数&nbsp;gethostbyname()：&nbsp;
<br>#include&nbsp;&lt;netdb.h&gt;;
<br>　　struct&nbsp;<a name="baidusnap1"></a><b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;*gethostbyname(const&nbsp;char&nbsp;*name);&nbsp;
<br>很明白<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是，它返回一个指向&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针。这个数据结构&nbsp;是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：
<br>　　&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;{
<br>　　&nbsp;char&nbsp;*h_name;
<br>　　&nbsp;char&nbsp;**h_aliases;
<br>　　&nbsp;int&nbsp;h_addrtype;
<br>　　&nbsp;int&nbsp;h_length;
<br>　　&nbsp;char&nbsp;**h_addr_list;
<br>　　&nbsp;};
<br>　　&nbsp;#define&nbsp;h_addr&nbsp;h_addr_list[0]&nbsp;
<br>这里是这个数据结构<b style="color: black; background-color: rgb(153, 255, 153);">的</b>详细资料：&nbsp;
<br>struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>:&nbsp;
<br>　　h_name&nbsp;–&nbsp;地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>正式名称。
<br>　　h_aliases&nbsp;–&nbsp;空字节-地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>预备名称<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针。
<br>　　h_addrtype&nbsp;–地址类型;&nbsp;通常是AF_INET。&nbsp;
<br>　　h_length&nbsp;–&nbsp;地址<b style="color: black; background-color: rgb(153, 255, 153);">的</b>比特长度。
<br>　　h_addr_list&nbsp;–&nbsp;零字节-主机网络地址指针。网络字节顺序。
<br>　　h_addr&nbsp;-&nbsp;h_addr_list中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>第一地址。
<br>gethostbyname()&nbsp;成功时返回一个指向结构体&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>指针，或者&nbsp;是个空&nbsp;(NULL)&nbsp;指针。(但是和以前不同，不设置errno，h_errno&nbsp;设置错&nbsp;误信息。请看下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;herror()。)&nbsp;
<br>但是如何<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>呢?&nbsp;有时候（我们可以从电脑手册中发现），向读者灌输&nbsp;信息是不够<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。这个函数可不象它看上去那么难用。
<br>这里是个例子：
<br>#include&nbsp;&lt;stdio.h&gt;;
<br>　　#include&nbsp;&lt;stdlib.h&gt;;
<br>　　#include&nbsp;&lt;errno.h&gt;;
<br>　　#include&nbsp;&lt;netdb.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;netinet/in.h&gt;;
<br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])
<br>　　&nbsp;{
<br>　　&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;*h;
<br>if&nbsp;(argc&nbsp;!=&nbsp;2)&nbsp;{&nbsp;/*&nbsp;检查命令行&nbsp;*/
<br>　　&nbsp;fprintf(stderr,"usage:&nbsp;getip&nbsp;address\n");
<br>　　&nbsp;exit(1);
<br>　　&nbsp;}
<br>if&nbsp;((h=gethostbyname(argv[1]))&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;取得地址信息&nbsp;*/
<br>　　&nbsp;herror("gethostbyname");
<br>　　&nbsp;exit(1);
<br>　　&nbsp;}
<br>printf("Host&nbsp;name&nbsp;:&nbsp;%s\n",&nbsp;h-&gt;;h_name);
<br>　　printf("IP&nbsp;Address&nbsp;:&nbsp;%s\n",inet_ntoa(*((struct&nbsp;in_addr&nbsp;*)h-&gt;;h_addr)));
<br>return&nbsp;0;
<br>　　&nbsp;}
<br>在<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;gethostbyname()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，你不能用&nbsp;perror()&nbsp;打印错误信息&nbsp;(因为&nbsp;errno&nbsp;没有<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>)，你应该调用&nbsp;herror()。
<br>相当简单，你只是传递一个保存机器名<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符串(例如&nbsp;"whitehouse.gov")&nbsp;给&nbsp;gethostbyname()，然后从返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;中获取信息。&nbsp;
<br>唯一也许让人不解<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是输出&nbsp;IP&nbsp;地址信息。h-&gt;;h_addr&nbsp;是一个&nbsp;char&nbsp;*，&nbsp;但是&nbsp;inet_ntoa()&nbsp;需要<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是&nbsp;struct&nbsp;in_addr。因此，我转换&nbsp;h-&gt;;h_addr&nbsp;成&nbsp;struct&nbsp;in_addr&nbsp;*，然后得到数据。
<br>--------------------------------------------------------------------------------
<br>客户-服务器背景知识
<br>　　这里是个客户--服务器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>世界。在网络上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>所有东西都是在处理客户进&nbsp;程和服务器进程<b style="color: black; background-color: rgb(153, 255, 153);">的</b>交谈。举个telnet&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>例子。当你用&nbsp;telnet&nbsp;(客户)通过23&nbsp;号端口登陆到主机，主机上运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>一个程序(一般叫&nbsp;telnetd，服务器)激活。&nbsp;它处理这个连接，显示登陆界面，等等。
<br>
<br>
<br>图2：客户机和服务器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>关系
<br>图&nbsp;2&nbsp;说明了客户和服务器之间<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息交换。&nbsp;
<br>注意，客户--服务器之间可以<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>SOCK_STREAM、SOCK_DGRAM&nbsp;或者其它(只要它们采用相同<b style="color: black; background-color: rgb(153, 255, 153);">的</b>)。一些很好<b style="color: black; background-color: rgb(153, 255, 153);">的</b>客户--服务器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>例子有&nbsp;telnet/telnetd、&nbsp;ftp/ftpd&nbsp;和&nbsp;bootp/bootpd。每次你<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;ftp&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，在远&nbsp;端都有一个&nbsp;ftpd&nbsp;为你服务。&nbsp;
<br>一般，在服务端只有一个服务器，它采用&nbsp;fork()&nbsp;来处理多个客户<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连&nbsp;接。基本<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序是：服务器等待一个连接，接受&nbsp;(accept())&nbsp;连接，然后&nbsp;fork()&nbsp;一个子进程处理它。这是下一章我们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>例子中会讲到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。
<br>--------------------------------------------------------------------------------
<br>简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>服务器
<br>　　这个服务器所做<b style="color: black; background-color: rgb(153, 255, 153);">的</b>全部工作是在流式连接上发送字符串&nbsp;"Hello,&nbsp;World!\n"。你要测试这个程序<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话，可以在一台机器上运行该程序，然后&nbsp;在另外一机器上登陆：&nbsp;
<br>　　&nbsp;$&nbsp;telnet&nbsp;remotehostname&nbsp;3490&nbsp;
<br>remotehostname&nbsp;是该程序运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器<b style="color: black; background-color: rgb(153, 255, 153);">的</b>名字。&nbsp;
<br>服务器代码：&nbsp;
<br>#include&nbsp;&lt;stdio.h&gt;;
<br>　　#include&nbsp;&lt;stdlib.h&gt;;
<br>　　#include&nbsp;&lt;errno.h&gt;;
<br>　　#include&nbsp;&lt;string.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;netinet/in.h&gt;;
<br>　　#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>　　#include&nbsp;&lt;sys/wait.h&gt;;
<br>#define&nbsp;MYPORT&nbsp;3490&nbsp;/*定义用户连接端口*/&nbsp;
<br>#define&nbsp;BACKLOG&nbsp;10&nbsp;/*多少等待连接控制*/&nbsp;
<br>main()&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　&nbsp;int&nbsp;sockfd,&nbsp;new_fd;&nbsp;/*&nbsp;listen&nbsp;on&nbsp;sock_fd,&nbsp;new&nbsp;connection&nbsp;on&nbsp;new_fd&nbsp;
<br>*/&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;my_addr;&nbsp;/*&nbsp;my&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;their_addr;&nbsp;/*&nbsp;connector's&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　&nbsp;int&nbsp;sin_size;
<br>if&nbsp;((sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>my_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_port&nbsp;=&nbsp;htons(MYPORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_addr.s_addr&nbsp;=&nbsp;INADDR_ANY;&nbsp;/*&nbsp;auto-fill&nbsp;with&nbsp;my&nbsp;IP&nbsp;*/&nbsp;
<br>　　&nbsp;bzero(&amp;amp;(my_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>
<br>if&nbsp;(bind(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;my_addr,&nbsp;sizeof(struct&nbsp;
<br>sockaddr))==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("bind");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>if&nbsp;(listen(sockfd,&nbsp;BACKLOG)&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("listen");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>while(1)&nbsp;{&nbsp;/*&nbsp;main&nbsp;accept()&nbsp;loop&nbsp;*/&nbsp;
<br>　　&nbsp;sin_size&nbsp;=&nbsp;sizeof(struct&nbsp;sockaddr_in);&nbsp;
<br>　　&nbsp;if&nbsp;((new_fd&nbsp;=&nbsp;accept(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;their_addr,&nbsp;\&nbsp;
<br>　　&nbsp;&amp;amp;sin_size))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("accept");&nbsp;
<br>　　&nbsp;continue;&nbsp;
<br>　　&nbsp;}&nbsp;
<br>　　&nbsp;printf("server:&nbsp;got&nbsp;connection&nbsp;from&nbsp;%s\n",&nbsp;\&nbsp;
<br>　　&nbsp;inet_ntoa(their_addr.sin_addr));&nbsp;
<br>　　&nbsp;if&nbsp;(!fork())&nbsp;{&nbsp;/*&nbsp;this&nbsp;is&nbsp;the&nbsp;child&nbsp;process&nbsp;*/&nbsp;
<br>　　&nbsp;if&nbsp;(send(new_fd,&nbsp;"Hello,&nbsp;world!\n",&nbsp;14,&nbsp;0)&nbsp;==&nbsp;-1)&nbsp;
<br>　　&nbsp;perror("send");&nbsp;
<br>　　&nbsp;close(new_fd);&nbsp;
<br>　　&nbsp;exit(0);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>　　&nbsp;close(new_fd);&nbsp;/*&nbsp;parent&nbsp;doesn't&nbsp;need&nbsp;this&nbsp;*/&nbsp;
<br>while(waitpid(-1,NULL,WNOHANG)&nbsp;&gt;;&nbsp;0);&nbsp;/*&nbsp;clean&nbsp;up&nbsp;child&nbsp;processes&nbsp;*/&nbsp;
<br>　　&nbsp;}&nbsp;
<br>　　&nbsp;}&nbsp;
<br>如果你很挑剔<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话，一定不满意我所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码都在一个很大<b style="color: black; background-color: rgb(153, 255, 153);">的</b>main()&nbsp;函数中。如果你不喜欢，可以划分得更细点。
<br>你也可以用我们下一章中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序得到服务器端发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符串。
<br>--------------------------------------------------------------------------------
<br>简单<b style="color: black; background-color: rgb(153, 255, 153);">的</b>客户程序&nbsp;
<br>　　这个程序比服务器还简单。这个程序<b style="color: black; background-color: rgb(153, 255, 153);">的</b>所有工作是通过&nbsp;3490&nbsp;端口连接到命令行中指定<b style="color: black; background-color: rgb(153, 255, 153);">的</b>主机，然后得到服务器发送<b style="color: black; background-color: rgb(153, 255, 153);">的</b>字符串。&nbsp;
<br>客户代码:&nbsp;
<br>#include&nbsp;&lt;stdio.h&gt;;
<br>　　#include&nbsp;&lt;stdlib.h&gt;;
<br>　　#include&nbsp;&lt;errno.h&gt;;
<br>　　#include&nbsp;&lt;string.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;netinet/in.h&gt;;
<br>　　#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>　　#include&nbsp;&lt;sys/wait.h&gt;;
<br>#define&nbsp;PORT&nbsp;3490&nbsp;/*&nbsp;客户机连接远程主机<b style="color: black; background-color: rgb(153, 255, 153);">的</b>端口&nbsp;*/&nbsp;
<br>#define&nbsp;MAXDATASIZE&nbsp;100&nbsp;/*&nbsp;每次可以接收<b style="color: black; background-color: rgb(153, 255, 153);">的</b>最大字节&nbsp;*/&nbsp;
<br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　&nbsp;int&nbsp;sockfd,&nbsp;numbytes;&nbsp;
<br>　　&nbsp;char&nbsp;buf[MAXDATASIZE];&nbsp;
<br>　　&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;*he;&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;their_addr;&nbsp;/*&nbsp;connector's&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>if&nbsp;(argc&nbsp;!=&nbsp;2)&nbsp;{&nbsp;
<br>　　&nbsp;fprintf(stderr,"usage:&nbsp;client&nbsp;hostname\n");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>if&nbsp;((he=gethostbyname(argv[1]))&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;get&nbsp;the&nbsp;host&nbsp;info&nbsp;*/&nbsp;
<br>　　&nbsp;herror("gethostbyname");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>if&nbsp;((sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>their_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　their_addr.sin_port&nbsp;=&nbsp;htons(PORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　their_addr.sin_addr&nbsp;=&nbsp;*((struct&nbsp;in_addr&nbsp;*)he-&gt;;h_addr);&nbsp;
<br>　　bzero(&amp;amp;(their_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>if&nbsp;(connect(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;their_addr,sizeof(struct&nbsp;
<br>sockaddr))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("connect");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>if&nbsp;((numbytes=recv(sockfd,&nbsp;buf,&nbsp;MAXDATASIZE,&nbsp;0))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("recv");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>buf[numbytes]&nbsp;=&nbsp;'\0';&nbsp;
<br>printf("Received:&nbsp;%s",buf);&nbsp;
<br>close(sockfd);&nbsp;
<br>return&nbsp;0;&nbsp;
<br>　　&nbsp;}&nbsp;
<br>注意，如果你在运行服务器之前运行客户程序，connect()&nbsp;将返回&nbsp;"Connection&nbsp;refused"&nbsp;信息，这非常有用。
<br>--------------------------------------------------------------------------------
<br>数据包&nbsp;Sockets&nbsp;
<br>　　我不想讲更多了，所以我给出代码&nbsp;talker.c&nbsp;和&nbsp;listener.c。&nbsp;
<br>listener&nbsp;在机器上等待在端口&nbsp;4590&nbsp;来<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据包。talker&nbsp;发送数据包到&nbsp;一定<b style="color: black; background-color: rgb(153, 255, 153);">的</b>机器，它包含用户在命令行输入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>内容。&nbsp;
<br>这里就是&nbsp;listener.c：&nbsp;
<br>#include&nbsp;&lt;stdio.h&gt;;
<br>　　#include&nbsp;&lt;stdlib.h&gt;;
<br>　　#include&nbsp;&lt;errno.h&gt;;
<br>　　#include&nbsp;&lt;string.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;netinet/in.h&gt;;
<br>　　#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>　　#include&nbsp;&lt;sys/wait.h&gt;;
<br>#define&nbsp;MYPORT&nbsp;4950&nbsp;/*&nbsp;the&nbsp;port&nbsp;users&nbsp;will&nbsp;be&nbsp;sending&nbsp;to&nbsp;*/&nbsp;
<br>#define&nbsp;MAXBUFLEN&nbsp;100&nbsp;
<br>main()&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　&nbsp;int&nbsp;sockfd;&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;my_addr;&nbsp;/*&nbsp;my&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;their_addr;&nbsp;/*&nbsp;connector's&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　&nbsp;int&nbsp;addr_len,&nbsp;numbytes;&nbsp;
<br>　　&nbsp;char&nbsp;buf[MAXBUFLEN];&nbsp;
<br>if&nbsp;((sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;0))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>my_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_port&nbsp;=&nbsp;htons(MYPORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;my_addr.sin_addr.s_addr&nbsp;=&nbsp;INADDR_ANY;&nbsp;/*&nbsp;auto-fill&nbsp;with&nbsp;my&nbsp;IP&nbsp;*/&nbsp;
<br>　　&nbsp;bzero(&amp;amp;(my_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>if&nbsp;(bind(sockfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;my_addr,&nbsp;sizeof(struct&nbsp;sockaddr))&nbsp;
<br>\&nbsp;
<br>　　&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("bind");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}
<br>addr_len&nbsp;=&nbsp;sizeof(struct&nbsp;sockaddr);&nbsp;
<br>　　&nbsp;if&nbsp;((numbytes=recvfrom(sockfd,&nbsp;buf,&nbsp;MAXBUFLEN,&nbsp;0,&nbsp;\&nbsp;
<br>　　&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;their_addr,&nbsp;&amp;amp;addr_len))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("recvfrom");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>printf("got&nbsp;packet&nbsp;from&nbsp;%s\n",inet_ntoa(their_addr.sin_addr));&nbsp;
<br>　　&nbsp;printf("packet&nbsp;is&nbsp;%d&nbsp;bytes&nbsp;long\n",numbytes);&nbsp;
<br>　　&nbsp;buf[numbytes]&nbsp;=&nbsp;'\0';&nbsp;
<br>　　&nbsp;printf("packet&nbsp;contains&nbsp;\"%s\"\n",buf);&nbsp;
<br>close(sockfd);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>注意在我们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()，我们最后<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>了&nbsp;SOCK_DGRAM。同时，&nbsp;没有必要去<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>&nbsp;listen()&nbsp;或者&nbsp;accept()。我们在<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>无连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据报套接&nbsp;字！&nbsp;
<br>下面是&nbsp;talker.c：&nbsp;
<br>#include&nbsp;&lt;stdio.h&gt;;
<br>　　#include&nbsp;&lt;stdlib.h&gt;;
<br>　　#include&nbsp;&lt;errno.h&gt;;
<br>　　#include&nbsp;&lt;string.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;netinet/in.h&gt;;
<br>　　#include&nbsp;&lt;sys/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.h&gt;;
<br>　　#include&nbsp;&lt;sys/wait.h&gt;;
<br>#define&nbsp;MYPORT&nbsp;4950&nbsp;/*&nbsp;the&nbsp;port&nbsp;users&nbsp;will&nbsp;be&nbsp;sending&nbsp;to&nbsp;*/&nbsp;
<br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　&nbsp;int&nbsp;sockfd;&nbsp;
<br>　　&nbsp;struct&nbsp;sockaddr_in&nbsp;their_addr;&nbsp;/*&nbsp;connector's&nbsp;address&nbsp;information&nbsp;*/&nbsp;
<br>　　&nbsp;struct&nbsp;<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>&nbsp;*he;&nbsp;
<br>　　&nbsp;int&nbsp;numbytes;&nbsp;
<br>
<br>if&nbsp;(argc&nbsp;!=&nbsp;3)&nbsp;{&nbsp;
<br>　　&nbsp;fprintf(stderr,"usage:&nbsp;talker&nbsp;hostname&nbsp;message\n");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>if&nbsp;((he=gethostbyname(argv[1]))&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;get&nbsp;the&nbsp;host&nbsp;info&nbsp;*/&nbsp;
<br>　　&nbsp;herror("gethostbyname");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>if&nbsp;((sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_DGRAM,&nbsp;0))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>
<br>their_addr.sin_family&nbsp;=&nbsp;AF_INET;&nbsp;/*&nbsp;host&nbsp;byte&nbsp;order&nbsp;*/&nbsp;
<br>　　&nbsp;their_addr.sin_port&nbsp;=&nbsp;htons(MYPORT);&nbsp;/*&nbsp;short,&nbsp;network&nbsp;byte&nbsp;order&nbsp;
<br>*/&nbsp;
<br>　　&nbsp;their_addr.sin_addr&nbsp;=&nbsp;*((struct&nbsp;in_addr&nbsp;*)he-&gt;;h_addr);&nbsp;
<br>　　&nbsp;bzero(&amp;amp;(their_addr.sin_zero),;&nbsp;/*&nbsp;zero&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;struct&nbsp;*/&nbsp;
<br>if&nbsp;((numbytes=sendto(sockfd,&nbsp;argv[2],&nbsp;strlen(argv[2]),&nbsp;0,&nbsp;\&nbsp;
<br>　　&nbsp;(struct&nbsp;sockaddr&nbsp;*)&amp;amp;their_addr,&nbsp;sizeof(struct&nbsp;sockaddr)))&nbsp;==&nbsp;-1)&nbsp;{&nbsp;
<br>　　&nbsp;perror("sendto");&nbsp;
<br>　　&nbsp;exit(1);&nbsp;
<br>　　&nbsp;}&nbsp;
<br>printf("sent&nbsp;%d&nbsp;bytes&nbsp;to&nbsp;
<br>%s\n",numbytes,inet_ntoa(their_addr.sin_addr));&nbsp;
<br>close(sockfd);&nbsp;
<br>return&nbsp;0;&nbsp;
<br>　　&nbsp;}&nbsp;
<br>这就是所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>了。在一台机器上运行&nbsp;listener，然后在另外一台机器上&nbsp;运行&nbsp;talker。观察它们<b style="color: black; background-color: rgb(153, 255, 153);">的</b>通讯！
<br>除了一些我在上面提到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据套接字连接<b style="color: black; background-color: rgb(153, 255, 153);">的</b>小细节外，对于数据套接&nbsp;字，我还得说一些，当一个讲话者呼叫connect()函数时并指定接受者<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地&nbsp;址时，从这点可以看出，讲话者只能向connect()函数指定<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地址发送和接&nbsp;受信息。因此，你不需要<b style="color: black; background-color: rgb(255, 153, 153);">使用</b>sendto()和recvfrom()，你完全可以用send()&nbsp;和recv()代替。
<br>--------------------------------------------------------------------------------
<br>阻塞&nbsp;
<br>　　阻塞，你也许早就听说了。"阻塞"是&nbsp;"sleep"&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>科技行话。你可能注意&nbsp;到前面运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;listener&nbsp;程序，它在那里不停地运行，等待数据包<b style="color: black; background-color: rgb(153, 255, 153);">的</b>到来。&nbsp;实际在运行<b style="color: black; background-color: rgb(153, 255, 153);">的</b>是它调用&nbsp;recvfrom()，然后没有数据，因此&nbsp;recvfrom()&nbsp;说"&nbsp;阻塞&nbsp;(block)"，直到数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>到来。
<br>很多函数都利用阻塞。accept()&nbsp;阻塞，所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;recv*()&nbsp;函数阻塞。它&nbsp;们之所以能这样做是因为它们被允许这样做。当你第一次调用&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>()&nbsp;建&nbsp;立套接字描述符<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，内核就将它设置为阻塞。如果你不想套接字阻塞，&nbsp;你就要调用函数&nbsp;fcntl()：&nbsp;
<br>#include&nbsp;&lt;unistd.h&gt;;
<br>　　#include&nbsp;&lt;fontl.h&gt;;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;sockfd&nbsp;=&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);&nbsp;
<br>　　&nbsp;fcntl(sockfd,&nbsp;F_SETFL,&nbsp;O_NONBLOCK);&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　&nbsp;.&nbsp;
<br>　　通过设置套接字为非阻塞，你能够有效地"询问"套接字以获得信息。如&nbsp;果你尝试着从一个非阻塞<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字读信息并且没有任何数据，它不允许阻&nbsp;塞--它将返回&nbsp;-1&nbsp;并将&nbsp;errno&nbsp;设置为&nbsp;EWOULDBLOCK。&nbsp;
<br>但是一般说来，这种询问不是个好主意。如果你让你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>程序在忙等状&nbsp;态查询套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据，你将浪费大量<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;CPU&nbsp;时间。更好<b style="color: black; background-color: rgb(153, 255, 153);">的</b>解决之道是用&nbsp;下一章讲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;select()&nbsp;去查询是否有数据要读进来。
<br>--------------------------------------------------------------------------------
<br>select()--多路同步&nbsp;I/O
<br>　　虽然这个函数有点奇怪，但是它很有用。假设这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>情况：你是个服&nbsp;务器，你一边在不停地从连接上读数据，一边在侦听连接上<b style="color: black; background-color: rgb(153, 255, 153);">的</b>信息。&nbsp;没问题，你可能会说，不就是一个&nbsp;accept()&nbsp;和两个&nbsp;recv()&nbsp;吗?&nbsp;这么&nbsp;容易吗，朋友?&nbsp;如果你在调用&nbsp;accept()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候阻塞呢?&nbsp;你怎么能够同时接&nbsp;受&nbsp;recv()&nbsp;数据?&nbsp;“用非阻塞<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套接字啊！”&nbsp;不行！你不想耗尽所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;CPU&nbsp;吧?&nbsp;那么，该如何是好?
<br>select()&nbsp;让你可以同时监视多个套接字。如果你想知道<b style="color: black; background-color: rgb(153, 255, 153);">的</b>话，那么它就&nbsp;会告诉你哪个套接字准备读，哪个又准备写，哪个套接字又发生了例外&nbsp;(exception)。
<br>闲话少说，下面是&nbsp;select()：
<br>#include&nbsp;&lt;sys/time.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;unistd.h&gt;;
<br>int&nbsp;select(int&nbsp;numfds,&nbsp;fd_set&nbsp;*readfds,&nbsp;fd_set&nbsp;*writefds,fd_set&nbsp;
<br>*exceptfds,&nbsp;struct&nbsp;timeval&nbsp;*timeout);
<br>这个函数监视一系列文件描述符，特别是&nbsp;readfds、writefds&nbsp;和&nbsp;exceptfds。如果你想知道你是否能够从标准输入和套接字描述符&nbsp;sockfd&nbsp;读入数据，你只要将文件描述符&nbsp;0&nbsp;和&nbsp;sockfd&nbsp;加入到集合&nbsp;readfds&nbsp;中。参&nbsp;数&nbsp;numfds&nbsp;应该等于最高<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符<b style="color: black; background-color: rgb(153, 255, 153);">的</b>值加1。在这个例子中，你应该&nbsp;设置该值为&nbsp;sockfd+1。因为它一定大于标准输入<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符&nbsp;(0)。&nbsp;当函数&nbsp;select()&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候，readfds&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>值修改为反映你选择<b style="color: black; background-color: rgb(153, 255, 153);">的</b>哪个&nbsp;文件描述符可以读。你可以用下面讲到<b style="color: black; background-color: rgb(153, 255, 153);">的</b>宏&nbsp;FD_ISSET()&nbsp;来测试。&nbsp;在我们继续下去之前，让我来讲讲如何对这些集合进行操作。每个集&nbsp;合类型都是&nbsp;fd_set。下面有一些宏来对这个类型进行操作：&nbsp;
<br>FD_ZERO(fd_set&nbsp;*set)&nbsp;–&nbsp;清除一个文件描述符集合
<br>　　FD_SET(int&nbsp;fd,&nbsp;fd_set&nbsp;*set)&nbsp;-&nbsp;添加fd到集合&nbsp;
<br>　　FD_CLR(int&nbsp;fd,&nbsp;fd_set&nbsp;*set)&nbsp;–&nbsp;从集合中移去fd&nbsp;
<br>　　FD_ISSET(int&nbsp;fd,&nbsp;fd_set&nbsp;*set)&nbsp;–&nbsp;测试fd是否在集合中&nbsp;
<br>最后，是有点古怪<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构&nbsp;struct&nbsp;timeval。有时你可不想永远等待&nbsp;别人发送数据过来。也许什么事情都没有发生<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候你也想每隔96秒在终&nbsp;端上打印字符串&nbsp;"Still&nbsp;Going..."。这个数据结构允许你设定一个时间，如果&nbsp;时间到了，而&nbsp;select()&nbsp;还没有找到一个准备好<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符，它将返回让&nbsp;你继续处理。&nbsp;
<br>数据结构&nbsp;struct&nbsp;timeval&nbsp;是这样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：&nbsp;
<br>struct&nbsp;timeval&nbsp;{&nbsp;
<br>　　&nbsp;int&nbsp;tv_sec;&nbsp;/*&nbsp;seconds&nbsp;*/&nbsp;
<br>　　&nbsp;int&nbsp;tv_usec;&nbsp;/*&nbsp;microseconds&nbsp;*/&nbsp;
<br>　　&nbsp;};&nbsp;
<br>只要将&nbsp;tv_sec&nbsp;设置为你要等待<b style="color: black; background-color: rgb(153, 255, 153);">的</b>秒数，将&nbsp;tv_usec&nbsp;设置为你要等待&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>微秒数就可以了。是<b style="color: black; background-color: rgb(153, 255, 153);">的</b>，是微秒而不是毫秒。1,000微秒等于1毫秒，1,000&nbsp;毫秒等于1秒。也就是说，1秒等于1,000,000微秒。为什么用符号&nbsp;"usec"&nbsp;呢?&nbsp;字母&nbsp;"u"&nbsp;很象希腊字母&nbsp;Mu，而&nbsp;Mu&nbsp;表示&nbsp;"微"&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>意思。当然，函数&nbsp;返回<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时候&nbsp;timeout&nbsp;可能是剩余<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时间，之所以是可能，是因为它依赖于&nbsp;你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;Unix&nbsp;操作系统。&nbsp;
<br>哈！我们现在有一个微秒级<b style="color: black; background-color: rgb(153, 255, 153);">的</b>定时器！别计算了，标准<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;Unix&nbsp;系统&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时间片是100毫秒，所以无论你如何设置你<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据结构&nbsp;struct&nbsp;timeval，&nbsp;你都要等待那么长<b style="color: black; background-color: rgb(153, 255, 153);">的</b>时间。&nbsp;
<br>还有一些有趣<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事情：如果你设置数据结构&nbsp;struct&nbsp;timeval&nbsp;中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>数据为&nbsp;0，select()&nbsp;将立即超时，这样就可以有效地轮询集合中<b style="color: black; background-color: rgb(153, 255, 153);">的</b>所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述&nbsp;符。如果你将参数&nbsp;timeout&nbsp;赋值为&nbsp;NULL，那么将永远不会发生超时，即&nbsp;一直等到第一个文件描述符就绪。最后，如果你不是很关心等待多长时间，&nbsp;那么就把它赋为&nbsp;NULL&nbsp;吧。&nbsp;
<br>下面<b style="color: black; background-color: rgb(153, 255, 153);">的</b>代码演示了在标准输入上等待&nbsp;2.5&nbsp;秒：&nbsp;
<br>#include&nbsp;&lt;sys/time.h&gt;;
<br>　　#include&nbsp;&lt;sys/types.h&gt;;
<br>　　#include&nbsp;&lt;unistd.h&gt;;
<br>#define&nbsp;STDIN&nbsp;0&nbsp;/*&nbsp;file&nbsp;descriptor&nbsp;for&nbsp;standard&nbsp;input&nbsp;*/&nbsp;
<br>main()&nbsp;
<br>　　&nbsp;{&nbsp;
<br>　　struct&nbsp;timeval&nbsp;tv;&nbsp;
<br>　　fd_set&nbsp;readfds;&nbsp;
<br>tv.tv_sec&nbsp;=&nbsp;2;&nbsp;
<br>　　tv.tv_usec&nbsp;=&nbsp;500000;&nbsp;
<br>FD_ZERO(&amp;amp;readfds);&nbsp;
<br>　　FD_SET(STDIN,&nbsp;&amp;amp;readfds);&nbsp;
<br>/*&nbsp;don't&nbsp;care&nbsp;about&nbsp;writefds&nbsp;and&nbsp;exceptfds:&nbsp;*/&nbsp;
<br>　　select(STDIN+1,&nbsp;&amp;amp;readfds,&nbsp;NULL,&nbsp;NULL,&nbsp;&amp;amp;tv);&nbsp;
<br>if&nbsp;(FD_ISSET(STDIN,&nbsp;&amp;amp;readfds))&nbsp;
<br>　　printf("A&nbsp;key&nbsp;was&nbsp;pressed!\n");&nbsp;
<br>　　else&nbsp;
<br>　　printf("Timed&nbsp;out.\n");&nbsp;
<br>　　}&nbsp;
<br>如果你是在一个&nbsp;line&nbsp;buffered&nbsp;终端上，那么你敲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>键应该是回车&nbsp;(RETURN)，否则无论如何它都会超时。
<br>现在，你可能回认为这就是在数据报套接字上等待数据<b style="color: black; background-color: rgb(153, 255, 153);">的</b>方式--你是对&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>：它可能是。有些&nbsp;Unix&nbsp;系统可以按这种方式，而另外一些则不能。你&nbsp;在尝试以前可能要先看看本系统<b style="color: black; background-color: rgb(153, 255, 153);">的</b>&nbsp;man&nbsp;page&nbsp;了。
<br>最后一件关于&nbsp;select()&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>事情：如果你有一个正在侦听&nbsp;(listen())&nbsp;<b style="color: black; background-color: rgb(153, 255, 153);">的</b>套&nbsp;接字，你可以通过将该套接字<b style="color: black; background-color: rgb(153, 255, 153);">的</b>文件描述符加入到&nbsp;readfds&nbsp;集合中来看是&nbsp;否有新<b style="color: black; background-color: rgb(153, 255, 153);">的</b>连接。
<br>这就是我关于函数select()&nbsp;要讲<b style="color: black; background-color: rgb(153, 255, 153);">的</b>所有<b style="color: black; background-color: rgb(153, 255, 153);">的</b>东西。
<br>　　参考书目:&nbsp;
<br>　　Internetworking&nbsp;with&nbsp;TCP/IP,&nbsp;volumes&nbsp;I-III&nbsp;by&nbsp;Douglas&nbsp;E.&nbsp;Comer&nbsp;and&nbsp;
<br>David&nbsp;L.&nbsp;Stevens.&nbsp;Published&nbsp;by&nbsp;Prentice&nbsp;Hall.&nbsp;Second&nbsp;edition&nbsp;ISBNs:&nbsp;
<br>0-13-468505-9,&nbsp;0-13-472242-6,&nbsp;0-13-474222-2.&nbsp;There&nbsp;is&nbsp;a&nbsp;third&nbsp;edition&nbsp;of&nbsp;
<br>this&nbsp;set&nbsp;which&nbsp;covers&nbsp;IPv6&nbsp;and&nbsp;IP&nbsp;over&nbsp;ATM.&nbsp;
<br>　　Using&nbsp;C&nbsp;on&nbsp;the&nbsp;UNIX&nbsp;System&nbsp;by&nbsp;David&nbsp;A.&nbsp;Curry.&nbsp;Published&nbsp;by&nbsp;
<br>O'Reilly&nbsp;&amp;amp;&nbsp;Associates,&nbsp;Inc.&nbsp;ISBN&nbsp;0-937175-23-4.&nbsp;
<br>　　TCP/IP&nbsp;Network&nbsp;Administration&nbsp;by&nbsp;Craig&nbsp;Hunt.&nbsp;Published&nbsp;by&nbsp;O'Reilly&nbsp;
<br>&amp;amp;&nbsp;Associates,&nbsp;Inc.&nbsp;ISBN&nbsp;0-937175-82-X.&nbsp;
<br>　　TCP/IP&nbsp;Illustrated,&nbsp;volumes&nbsp;1-3&nbsp;by&nbsp;W.&nbsp;Richard&nbsp;Stevens&nbsp;and&nbsp;Gary&nbsp;R.&nbsp;
<br>Wright.&nbsp;Published&nbsp;by&nbsp;Addison&nbsp;Wesley.&nbsp;ISBNs:&nbsp;0-201-63346-9,&nbsp;
<br>0-201-63354-X,&nbsp;0-201-63495-3.&nbsp;
<br>Unix&nbsp;Network&nbsp;Programming&nbsp;by&nbsp;W.&nbsp;Richard&nbsp;Stevens.&nbsp;Published&nbsp;by&nbsp;
<br>Prentice&nbsp;Hall.&nbsp;ISBN&nbsp;0-13-949876-1.&nbsp;
<br>　　On&nbsp;the&nbsp;web:&nbsp;
<br>　　BSD&nbsp;Sockets:&nbsp;A&nbsp;Quick&nbsp;And&nbsp;Dirty&nbsp;Primer&nbsp;
<br>　　(http://www.cs.umn.edu/~bentlema/unix/--has&nbsp;other&nbsp;great&nbsp;Unix&nbsp;
<br>system&nbsp;programming&nbsp;info,&nbsp;too!)&nbsp;
<br>Client-Server&nbsp;Computing&nbsp;
<br>　　(http://pandonia.canberra.edu.au/ClientServer/<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>.html)&nbsp;
<br>Intro&nbsp;to&nbsp;TCP/IP&nbsp;(gopher)&nbsp;
<br>
<br>(gopher://gopher-chem.ucdavis.edu/11/Index/Internet_aw/Intro_the_Inter
<br>net/intro.to.ip/)&nbsp;
<br>Internet&nbsp;Protocol&nbsp;Frequently&nbsp;Asked&nbsp;Questions&nbsp;(France)&nbsp;
<br>　　(http://web.cnam.fr/Network/TCP-IP/)&nbsp;
<br>The&nbsp;Unix&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">Socket</b>&nbsp;FAQ&nbsp;
<br>　　(http://www.ibrado.com/sock-faq/)&nbsp;
<br>RFCs--the&nbsp;real&nbsp;dirt:&nbsp;
<br>　　RFC-768&nbsp;--&nbsp;The&nbsp;User&nbsp;Datagram&nbsp;Protocol&nbsp;(UDP)&nbsp;
<br>　&nbsp;　(ftp://nic.ddn.mil/rfc/rfc768.txt)&nbsp;
<br>RFC-791&nbsp;--&nbsp;The&nbsp;Internet&nbsp;Protocol&nbsp;(IP)&nbsp;
<br>　　(ftp://nic.ddn.mil/rfc/rfc791.txt)&nbsp;
<br>RFC-793&nbsp;--&nbsp;The&nbsp;Transmission&nbsp;Control&nbsp;Protocol&nbsp;(TCP)&nbsp;
<br>　　&nbsp;(ftp://nic.ddn.mil/rfc/rfc793.txt)&nbsp;
<br>RFC-854&nbsp;--&nbsp;The&nbsp;Telnet&nbsp;Protocol&nbsp;
<br>　　&nbsp;(ftp://nic.ddn.mil/rfc/rfc854.txt)&nbsp;
<br>RFC-951&nbsp;--&nbsp;The&nbsp;Bootstrap&nbsp;Protocol&nbsp;(BOOTP)&nbsp;
<br>　(ftp://nic.ddn.mil/rfc/rfc951.txt)&nbsp;
<br>RFC-1350&nbsp;--&nbsp;The&nbsp;Trivial&nbsp;File&nbsp;Transfer&nbsp;Protocol&nbsp;(TFTP)&nbsp;
<br>　　&nbsp;(ftp://nic.ddn.mil/rfc/rfc1350.txt)<br>
<br>
<br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=13232" target="_top">deathcult</a> 回复于：2003-04-24 11:39:37</b><br><br>
c&nbsp;<b style="color: black; background-color: rgb(255, 255, 102);">socket</b>,&nbsp;it&nbsp;is&nbsp;....<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=19894" target="_top">rimrock</a> 回复于：2003-04-24 11:55:17</b><br><br>
hao<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=366" target="_top">流浪者</a> 回复于：2003-04-24 12:04:30</b><br><br>
perl<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>函数跟C<b style="color: black; background-color: rgb(255, 153, 153);">使用</b><b style="color: black; background-color: rgb(153, 255, 153);">的</b>一样。<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=13232" target="_top">deathcult</a> 回复于：2003-04-24 14:29:26</b><br><br>
当然不一样!!!<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=366" target="_top">流浪者</a> 回复于：2003-04-24 18:29:54</b><br><br>
基本上是一样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>。<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=56075" target="_top">happy_cfx</a> 回复于：2003-05-18 18:47:32</b><br><br>
好！！<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=49824" target="_top">轩辕砍刀</a> 回复于：2003-05-18 19:54:00</b><br><br>
hao<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=57292" target="_top">zxwty</a> 回复于：2003-05-24 15:55:31</b><br><br>
:oops:&nbsp;[color=olive]精华，thanks[/color]<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=139912" target="_top">joesin</a> 回复于：2004-03-29 14:57:01</b><br><br>
我不会用linux或unix，只想问下windows下<b style="color: black; background-color: rgb(153, 255, 153);">的</b><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>和linux下<b style="color: black; background-color: rgb(153, 255, 153);">的</b><b style="color: black; background-color: rgb(255, 255, 102);">socket</b>有什么不一样<b style="color: black; background-color: rgb(153, 255, 153);">的</b>？
<br>我要考网设，该怎么定位啊，下午所考<b style="color: black; background-color: rgb(153, 255, 153);">的</b>又是哪种啊？有人回答我吗？
<br>qq：30305581<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=383740" target="_top">robin30</a> 回复于：2006-03-14 10:32:42</b><br><br>
牛啊，你是我<b style="color: black; background-color: rgb(153, 255, 153);">的</b>偶像——流浪者，看到加我QQ啊181613640<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=97016" target="_top">jeffshia</a> 回复于：2006-09-01 22:38:31</b><br><br>
这跟perl什么关系啊<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=356388" target="_top">Suchangyu</a> 回复于：2006-10-21 18:49:21</b><br><br>
楼主，为什么编译客户端程序，如下语句：
<br><pre>their_addr.sin_addr&nbsp;=&nbsp;*((struct&nbsp;in_addr&nbsp;*)he-&gt;h_addr);&nbsp;</pre>
<br>
<br>出现了这个错误：
<br>引用：<i>
<br>client.c:32:&nbsp;dereferencing&nbsp;pointer&nbsp;to&nbsp;incomplete&nbsp;type
<br></i><br><br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=356388" target="_top">Suchangyu</a> 回复于：2006-10-21 21:27:09</b><br><br>
原来是没有引入头文件netdb.h。
<br>此文件是声明gethostbyname函数和定义<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>结构<b style="color: black; background-color: rgb(153, 255, 153);">的</b>地方，那么没有这个头文件，应该报告“没有定义<b style="color: black; background-color: rgb(160, 255, 255);">hostent</b>”之类<b style="color: black; background-color: rgb(153, 255, 153);">的</b>错误啊，为什么会出dereferencing&nbsp;pointer&nbsp;to&nbsp;incomplete&nbsp;type<b style="color: black; background-color: rgb(153, 255, 153);">的</b>错误呢？？？
<br>
<br>是不是GCC（3.2）<b style="color: black; background-color: rgb(153, 255, 153);">的</b>bug？<br><br>[<u>&nbsp;本帖最后由&nbsp;Suchangyu&nbsp;于&nbsp;2006-10-21&nbsp;21:35&nbsp;编辑&nbsp;</u>]<br><br>
<hr><b>&nbsp;<a href="http://bbs.chinaunix.net/viewpro.php?uid=648967" target="_top">lan.happy</a> 回复于：2008-04-20 15:21:55</b><br><br>
好文章<br><br>

<br>
<br>
</td></tr>
<tr><td bgcolor="#747474" height="1"><img src="c.gif" height="1" width="1"></td></tr>
<tr><td><br>
原文链接：<a href="http://bbs.chinaunix.net/viewthread.php?tid=48248">http://bbs.chinaunix.net/viewthread.php?tid=48248</a><br>
转载请注明作者名及原文出处<br><br><br>
                          
  </td></tr></tbody></table>
<!-- 正文end -->
	
		</font></td></tr>
	</tbody></table>
</td></tr>
</tbody></table>

<hr size="2" width="760">

</center>




</div>



</body>
</html>
