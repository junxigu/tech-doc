<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<meta content="IE=7" http-equiv="X-UA-Compatible">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" name="viewport">
<link href="http://img.baidu.com/img/baike/wap/iphone4_logo.png" rel="apple-touch-icon">
<meta content="6cxg7fjbSrYQta0LB_ceiPVV7KOb9Sis_o0e4QGYDec" name="google-site-verification"><title>STL set_百度百科</title>



<link rel="stylesheet" type="text/css" href="index.css" media="all">

<link rel="stylesheet" id="scrapbook-sticky-css" type="text/css" href="chrome://scrapbook/skin/annotation.css" media="all">
</head>
<body id="view"><iframe src="index_1.html" style="display: none;" frameborder="0"></iframe><div id="bdshare_s"><iframe src="index_2.html" id="bdsIfr" style="position: absolute; display: none; z-index: 9999;" frameborder="0"></iframe><div style="display: none;" id="bdshare_l"><div id="bdshare_l_c"><h6>分享到</h6><ul><li><a href="#" class="bds_qzone qqkj">QQ空间</a></li><li><a href="#" class="bds_tsina xlwb">新浪微博</a></li><li><a href="#" class="bds_baidu bdsc">百度搜藏</a></li><li><a href="#" class="bds_renren rrw">人人网</a></li><li><a href="#" class="bds_tqq txwb">腾讯微博</a></li><li><a href="#" class="bds_kaixin001 kxw">开心网</a></li><li><a href="#" class="bds_tqf txpy">腾讯朋友</a></li><li><a href="#" class="bds_hi bdkj">百度空间</a></li><li><a href="#" class="bds_douban db">豆瓣网</a></li><li><a href="#" class="bds_tsohu shwb">搜狐微博</a></li><li><a href="#" class="bds_msn msn">MSN</a></li><li><a href="#" class="bds_qq qqsc">QQ收藏</a></li><li><a href="#" class="bds_taobao tjh">淘宝</a></li><li><a href="#" class="bds_tieba bdtb">百度贴吧</a></li><li><a href="#" class="bds_sohu shbsh">搜狐白社会</a></li><li><a href="#" class="bds_more">更多...</a></li></ul><p><a href="#" class="goWebsite">百度分享</a></p></div></div></div>
<div id="userbar"><ul><li></li><li class="line">|</li></ul></div>
<div id="wrap">

<div id="page">
<div class="layout grid-m0s245 w1000" id="content-wrap">
<div class="col-main article" id="content">
<div class="main-wrap main-shadow" id="main-wrap">
<div class="content-hd">
<div class="content-hd-wrap"></div>
</div>
<div class="content-bd main-body">
<div class="text" id="sec-content0">
<div class="bk-editable-lemma-btns">
<a class="tpldivide-lemma lemma-top-link" hidefocus="true" href="http://baike.baidu.com/tpldivideload?lemmaId=4255961" id="tmpdivide" style="display: none; margin-right: 14px;" target="_top"></a>
<a class="dividable-lemma lemma-top-link" data-edit-id="4255961" hidefocus="true" href="http://baike.baidu.com/divideload?lemmaid=4255961" id="polyin" style="display: none;">拆分词条</a>

<span style="height: 100%;"></span>
</div>
<h1 class="title" id="lemmaTitle-4255961">STL set</h1>


<div class="clear"></div>
<div class="mod-top">

<div class="card-summary nslog-area" data-nslog-type="72">

<div class="card-summary-content">
<p>
STL 对这个序列可以进行查找，插入删除序列中的任意一个元素，而完成这些操作的时间同这个序列中元素个数的对数成比例关系，并且当游标指向一个已删除的元素时，删除操作无效。而一个经过更正的和更加实际的定义应该是：<span style="border-bottom: medium solid rgb(51, 255, 51);" class="linemarker-marked-line">一个集合(set)是一个容器，它其中所包含的元素的值是唯一的</span>。这在收集一个数据的具体值的时候是有用的。<span style="border-bottom: medium solid rgb(51, 255, 51);" class="linemarker-marked-line">集合中的元素按一定的顺序排列，并被作为集合中的实例</span>。一个集合通过一个链表来组织，在插入操作和删除操作上比向量(vector)快，但查找或添加末尾的元素时会有些慢。<span style="border-bottom: medium solid rgb(51, 255, 51);" class="linemarker-marked-line">具体实现采用了红黑树的平衡二叉树的</span><a target="_top" href="http://baike.baidu.com/view/9900.htm"><span style="border-bottom: medium solid rgb(51, 255, 51);" class="linemarker-marked-line">数据结构</span></a><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line"></span>。</p>
</div>
<div class="clear"></div>
</div>
</div>
<fieldset class="text_dir nslog-area log-set-param" data-nslog-type="1016" data-subindex="0" id="catalog-0" log-set-param="catalogshow">


<dl class="holder2" id="catalog-holder-2-0"></dl>
</fieldset>
<div class="clear"></div>

<div class="lemma-main-content" id="lemmaContent-0">
<h2 class="headline-1 first bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="4255961:4255961:1"></span><a name="1"></a><a name="sub4255961_1"></a><span class="headline-content">集和多集（set 和multiset 容器类）</span></h2>　　#include &lt;set&gt;
<div class="spctrl"></div>　　一个集合（set）是一个容器，它其中所包含的元素的值是唯一的。
<div class="spctrl"></div>　　集和多集的区别是：set支持唯一键值，set中的值都是特定的，而且只出现一次；而multiset中可以出现副本键，同一值可以出现多次。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="4255961:4255961:2"></span><a name="2"></a><a name="sub4255961_2"></a><span class="headline-content">构造</span></h2>　　explicit set(const Compare&amp;=compare());
<div class="spctrl"></div>　　如：set&lt;int,less&lt;int&gt; &gt; set1;
<div class="spctrl"></div>　　less&lt;int&gt;是一个标准类，用于形成升序排列函数对象。降序排列是用greater&lt;int&gt;。
<div class="spctrl"></div>　　Template&lt;class InputIterator&gt; set(InputIterator, InputIterator,\ const Compare&amp;=compare());
<div class="spctrl"></div>　　如：set&lt;int ,less&lt;int&gt; &gt;set2(vector1.begin(),vector1.end());
<div class="spctrl"></div>　　通过指定某一预先定义的区间来初始化set对象的构造函数。
<div class="spctrl"></div>　　set（const set&lt;Key,Compare&amp;&gt;）; 
<div class="spctrl"></div>　　如：set&lt;int ,less&lt;int&gt; &gt;set3(set2); 
<div class="spctrl"></div>　　。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="4255961:4255961:3"></span><a name="3"></a><a name="sub4255961_3"></a><span class="headline-content">方法：</span></h2>　　begin() 返回指向第一个元素的迭代器
<div class="spctrl"></div>　　clear() 清除所有元素
<div class="spctrl"></div>　　<span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">count() 返回某个值元素的个数
</span><div class="spctrl"></div>　　empty() 如果集合为空，返回true
<div class="spctrl"></div>　　end() 返回指向最后一个元素之后的迭代器，不是最后一个元素
<div class="spctrl"></div>　　<span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">equal_range() 返回集合中与给定值相等的上下限的两个迭代器</span>
<div class="spctrl"></div>　　erase() 删除集合中的元素
<div class="spctrl"></div>　　<span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">find() 返回一个指向被查找到元素的迭代器
</span><div class="spctrl"></div>　　get_allocator() 返回集合的分配器
<div class="spctrl"></div>　　insert() 在集合中插入元素
<div class="spctrl"></div>　　<span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">lower_bound() 返回指向大于（或等于）某值的第一个元素的迭代器
</span><div class="spctrl"></div>　　key_comp() 返回一个用于元素间值比较的函数
<div class="spctrl"></div>　　max_size() 返回集合能容纳的元素的最大限值
<div class="spctrl"></div>　　rbegin() 返回指向集合中最后一个元素的反向迭代器
<div class="spctrl"></div>　　rend() 返回指向集合中第一个元素的反向迭代器
<div class="spctrl"></div>　　size() 集合中元素的数目
<div class="spctrl"></div>　　swap() 交换两个集合变量
<div class="spctrl"></div>　　<a target="_top" href="http://baike.baidu.com/view/4163451.htm">upper_bound</a>() 返回大于某个值元素的迭代器
<div class="spctrl"></div>　　value_comp() 返回一个用于比较元素间的值的函数<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="4255961:4255961:4"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",4255961,4255961,4);return false'>编辑本段</a></span><a name="4"></a><a name="sub4255961_4"></a><span class="headline-content">集合操作：</span></h2>　　std::set_intersection() :这个函数是求两个集合的交集。
<div class="spctrl"></div>　　std::set_union() :求两个集合的并集
<div class="spctrl"></div>　　std::<a target="_top" href="http://baike.baidu.com/view/1936199.htm">set_difference</a>（）：差集
<div class="spctrl"></div>　　std::set_symmetric_difference（）：得到的结果是第一个迭代器相对于第二个的差集并 上第二个相当于第一个的差集
<div class="spctrl"></div>　　struct compare{
<div class="spctrl"></div>　　bool operator ()(string s1,string s2){
<div class="spctrl"></div>　　return s1&gt;s2;
<div class="spctrl"></div>　　}///自定义一个仿函数
<div class="spctrl"></div>　　};
<div class="spctrl"></div>　　std::set&lt;string,compare&gt; s
<div class="spctrl"></div>　　string str[10];
<div class="spctrl"></div>　　<span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line"></span><span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">string *end = set_intersection(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//求交集，返回值指向str最后一个元素的尾端
</span></span></span><div class="spctrl"></div><span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">　　end = std::set_union(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//并集
</span></span></span><div class="spctrl"></div><span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">　　end = std::set_difference(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//s2相对于s1的差集
</span></span></span><div class="spctrl"></div><span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">　　end = std::set_difference(s2.begin(),s2.end(),s.begin(),s.end(),str,compare());//s1相对于s2的差集
</span></span></span><div class="spctrl"></div><span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">　　end = std::set_symmetric_difference(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());</span></span></span><span><span style="border-bottom: medium solid #33FF33;" class="linemarker-marked-line">//上面两个差集的并集</span></span><div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="4255961:4255961:5"></span><a name="5"></a><a name="sub4255961_5"></a><span class="headline-content">例子：</span></h2><div class="spctrl"></div>　　#include &lt;iostream&gt;
<div class="spctrl"></div>　　#include &lt;set&gt;
<div class="spctrl"></div>　　using namespace std;
<div class="spctrl"></div>　　int main(void)
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　set&lt;int&gt; set1;
<div class="spctrl"></div>　　for(int i=0; i&lt;10; ++i)
<div class="spctrl"></div>　　set1.insert(i);
<div class="spctrl"></div>　　for(set&lt;int&gt;::iterator p=set1.begin();p!=set1.end();++p)
<div class="spctrl"></div>　　cout&lt;&lt;*p&lt;&lt;"";
<div class="spctrl"></div>　　if(set1.insert(3).second)//把3插入到set1中
<div class="spctrl"></div>　　//插入成功则set1.insert(3).second返回1，否则返回0
<div class="spctrl"></div>　　//此例中，集中已经有3这个元素了，所以插入将失败
<div class="spctrl"></div>　　cout&lt;&lt;"set insert success";
<div class="spctrl"></div>　　else
<div class="spctrl"></div>　　cout&lt;&lt;"set insert failed"; 
<div class="spctrl"></div>　　int a[] = {4, 1, 1, 1, 1, 1, 0, 5, 1, 0};
<div class="spctrl"></div>　　multiset&lt;int&gt; A;
<div class="spctrl"></div>　　A.insert(set1.begin(),set1.end());
<div class="spctrl"></div>　　A.insert(a,a+10);
<div class="spctrl"></div>　　cout&lt;&lt;endl;
<div class="spctrl"></div>　　for(multiset&lt;int&gt;::iterator p=A.begin();p!=A.end();++p)
<div class="spctrl"></div>　　cout&lt;&lt;*p&lt;&lt;" "; 
<div class="spctrl"></div><div class="spctrl"></div>　　return 0;
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　2////////////////////////////////////////
<div class="spctrl"></div>　　#include &lt;iostream&gt;
<div class="spctrl"></div>　　#include &lt;set&gt;
<div class="spctrl"></div>　　#include &lt;string&gt;
<div class="spctrl"></div>　　#include &lt;algorithm&gt;
<div class="spctrl"></div>　　using namespace std;
<div class="spctrl"></div>　　struct compare
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　bool operator ()(string s1,string s2)
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　return s1&gt;s2;
<div class="spctrl"></div>　　}<div class="spctrl"></div>　　};
<div class="spctrl"></div>　　int main()
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　typedef std::set&lt;string,compare&gt; _SET;
<div class="spctrl"></div>　　_SET s;
<div class="spctrl"></div>　　s.insert(string("sfdsfd"));
<div class="spctrl"></div>　　s.insert(string("apple"));
<div class="spctrl"></div>　　s.insert(string("english"));
<div class="spctrl"></div>　　s.insert(string("dstd"));
<div class="spctrl"></div>　　cout&lt;&lt;"s1:"&lt;&lt;endl;
<div class="spctrl"></div>　　std::set&lt;string,compare&gt;::iterator it = s.begin();
<div class="spctrl"></div>　　while(it!=s.end())
<div class="spctrl"></div>　　cout&lt;&lt;*it++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;"s2:"&lt;&lt;endl;
<div class="spctrl"></div>　　_SET s2;
<div class="spctrl"></div>　　s2.insert(string("abc"));
<div class="spctrl"></div>　　s2.insert(string("apple"));
<div class="spctrl"></div>　　s2.insert(string("english"));
<div class="spctrl"></div>　　it = s2.begin();
<div class="spctrl"></div>　　while(it!=s2.end())
<div class="spctrl"></div>　　cout&lt;&lt;*it++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;endl;
<div class="spctrl"></div>　　string str[10];
<div class="spctrl"></div>　　string *end = set_intersection(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//求交集，返回值指向str最后一个元素的尾端
<div class="spctrl"></div>　　cout&lt;&lt;"result of set_intersection s1,s2:"&lt;&lt;endl;
<div class="spctrl"></div>　　string *first = str;
<div class="spctrl"></div>　　while(first&lt;end)
<div class="spctrl"></div>　　cout &lt;&lt;*first++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"result of set_union of s1,s2"&lt;&lt;endl;
<div class="spctrl"></div>　　end = std::set_union(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//并集 first = str;
<div class="spctrl"></div>　　while(first&lt;end)
<div class="spctrl"></div>　　cout &lt;&lt;*first++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"result of set_difference of s2 relative to s1"&lt;&lt;endl; 
<div class="spctrl"></div>　　first = str;
<div class="spctrl"></div>　　end = std::set_difference(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//s2相对于s1的差集 while(first&lt;end)
<div class="spctrl"></div>　　cout &lt;&lt;*first++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"result of set_difference of s1 relative to s2"&lt;&lt;endl; 
<div class="spctrl"></div>　　first = str;
<div class="spctrl"></div>　　end = std::set_difference(s2.begin(),s2.end(),s.begin(),s.end(),str,compare());//s1相对于s2的差集
<div class="spctrl"></div>　　while(first&lt;end)
<div class="spctrl"></div>　　cout &lt;&lt;*first++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl&lt;&lt;endl;
<div class="spctrl"></div>　　first = str;
<div class="spctrl"></div>　　end = std::set_symmetric_difference(s.begin(),s.end(),s2.begin(),s2.end(),str,compare());//上面两个差集的并集 while(first&lt;end)
<div class="spctrl"></div>　　cout &lt;&lt;*first++&lt;&lt;" ";
<div class="spctrl"></div>　　cout&lt;&lt;endl; 
<div class="spctrl"></div>　　}<div class="bpctrl" style="clear: both;"></div><div class="clear"></div>
</div>
<div class="clear"></div>

<div class="reinforce" id="lemmaExtend">
<div class="clear"></div>
</div>

</div>
<div class="clear"></div>
</div>

</div>
</div>

</div><img src="c.gif" style="display: none;"><input id="titleVal" value="STL set" type="hidden">
</div>

</div>
<div id="sidecatalog" style="position: fixed; display: none; top: 431px; left: 744px;">
<div class="sidebar" id="sidebar"></div>
<a class="gotop" href="#" id="gotop" title="返回顶部"></a>
</div>
<div id="side-catalog-content" style="display: none; position: fixed; overflow: hidden; height: 180px; top: 341px; left: 771px;"><div id="side-catalog-up"><div></div></div><div id="side-lemma-title">STL set</div><div style="height: 110px;" id="side-title-panel"><div id="side-title-list"><h2><a href="#1" class="nslog:1026" title="集和多集（set 和multiset 容器类）">集和多集（set 和multiset 容...</a></h2><h2><a href="#2" class="nslog:1026" title="构造">构造</a></h2><h2><a href="#3" class="nslog:1026" title="方法：">方法：</a></h2><h2><a href="#4" class="nslog:1026" title="集合操作：">集合操作：</a></h2><h2><a href="#5" class="nslog:1026" title="例子：">例子：</a></h2></div></div><div id="side-catalog-down"><div></div></div></div>




<div id="usercard-wrap"><div style="opacity: 0;" class="user-card fix"><div class="top-bg"></div><div class="card-body fix"><div class="uc-l"><div class="uc-pic"></div><div class="uc-name"><a class="uc-id" href="http://baike.baidu.com/view/4255961.htm"></a></div><div class="uc-level"></div></div><div class="uc-r"><div class="uc-items"><div class="uc-role fix"></div><div class="uc-badge fix"></div><div class="uc-honor"></div><div class="uc-going-task fix"></div><div class="uc-gq"></div><div class="uc-default"></div><div class="uc-edit"></div></div><span class="pillar"></span></div></div></div></div>



<div class="scrapbook-sticky" style="left: 774px; top: 17px; position: absolute; width: 253px; height: 136px;"><div class="scrapbook-sticky-header"></div>构造函数：
set&lt;int, less&lt;int&gt; &gt; c;
set&lt;int, less&lt;int&gt; &gt; c( c1 );
set&lt;int, less&lt;int&gt; &gt; c( vector.begin(), vector.end() );</div>
<div class="scrapbook-sticky" style="left: 773px; top: 156px; position: absolute; width: 254px; height: 148px;"><div class="scrapbook-sticky-header"></div>修改函数：如vector
c.erase();
c.clear();
c.insert();

c.swap();</div>
<div class="scrapbook-sticky" style="left: 772px; top: 306px; position: absolute; width: 250px; height: 107px;"><div class="scrapbook-sticky-header"></div>容量函数：
c.empty();
c.size();
c.count();

</div>
<div class="scrapbook-sticky" style="left: 773px; top: 419px; position: absolute; width: 260px; height: 187px;"><div class="scrapbook-sticky-header"></div>引用函数：
c.front();
c.back();

c.find();
c.lower_bound();
c.upper_bound();
c.begin();
c.end();</div>
<div class="scrapbook-sticky" style="left: 772px; top: 610px; position: absolute; width: 269px; height: 158px;"><div class="scrapbook-sticky-header"></div>集合操作：
set_intersection( c1 );
set_union( c1 );
set_difference();
set_symmetric_difference();
用法参考下文</div>




</body></html>
