<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<meta content="IE=7" http-equiv="X-UA-Compatible">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" name="viewport">
<link href="http://img.baidu.com/img/baike/wap/iphone4_logo.png" rel="apple-touch-icon">
<title>volatile_百度百科</title>



<link rel="stylesheet" type="text/css" href="index.css" media="all">
</head>
<body id="view"><iframe src="index_1.html" style="display: none;" frameborder="0"></iframe><div id="bdshare_s"><iframe src="index_2.html" id="bdsIfr" style="position: absolute; display: none; z-index: 9999;" frameborder="0"></iframe><div style="display: none;" id="bdshare_l"><div id="bdshare_l_c"><h6>分享到</h6><ul><li><a href="#" class="bds_qzone qqkj">QQ空间</a></li><li><a href="#" class="bds_tsina xlwb">新浪微博</a></li><li><a href="#" class="bds_baidu bdsc">百度搜藏</a></li><li><a href="#" class="bds_renren rrw">人人网</a></li><li><a href="#" class="bds_tqq txwb">腾讯微博</a></li><li><a href="#" class="bds_kaixin001 kxw">开心网</a></li><li><a href="#" class="bds_tqf txpy">腾讯朋友</a></li><li><a href="#" class="bds_hi bdkj">百度空间</a></li><li><a href="#" class="bds_douban db">豆瓣网</a></li><li><a href="#" class="bds_tsohu shwb">搜狐微博</a></li><li><a href="#" class="bds_msn msn">MSN</a></li><li><a href="#" class="bds_qq qqsc">QQ收藏</a></li><li><a href="#" class="bds_taobao tjh">淘宝</a></li><li><a href="#" class="bds_tieba bdtb">百度贴吧</a></li><li><a href="#" class="bds_sohu shbsh">搜狐白社会</a></li><li><a href="#" class="bds_more">更多...</a></li></ul><p><a href="#" class="goWebsite">百度分享</a></p></div></div></div>
<div id="userbar"><ul><li><a href="http://www.baidu.com/" class="nslog:87">百度首页</a></li><li class="line">|</li><li><a href="https://passport.baidu.com/?login&amp;tpl=wk" class="nslog:88" onclick="nslog(location.href, 3721, {fr:1});userlogin();return false">登录</a><a href="javascript:;" onclick="userlogin.reg();return false">注册</a></li></ul></div>
<div id="wrap">
<div id="header">
<div id="search">
<div id="logo">
<a href="http://baike.baidu.com/"><img alt="到百科首页" class="nslog:1008" src="logo-baike.png" border="0" height="46" width="137"></a>
</div>
<div id="search-content">
<p class="nv nslog-area" data-nslog-type="1009">
<a href="http://news.baidu.com/ns?fr=bk&amp;cl=2&amp;rn=20&amp;tn=news&amp;word=volatile" onmousedown="setHeadUrl(this)" wdfield="word">新闻</a><a href="http://www.baidu.com/s?fr=bk&amp;cl=3&amp;wd=volatile&amp;t=5" onmousedown="setHeadUrl(this)" wdfield="wd">网页</a><a href="http://tieba.baidu.com/f?fr=bk&amp;kw=volatile" onmousedown="setHeadUrl(this)" wdfield="kw">贴吧</a><a href="http://zhidao.baidu.com/q?fr=bk&amp;ct=17&amp;pn=0&amp;tn=ikaslist&amp;rn=10&amp;word=volatile" onmousedown="setHeadUrl(this)" wdfield="word">知道</a><a href="http://mp3.baidu.com/m?fr=bk&amp;tn=baidump3&amp;ct=134217728&amp;lm=-1&amp;word=volatile" onmousedown="setHeadUrl(this)" wdfield="word">MP3</a><a href="http://image.baidu.com/i?fr=bk&amp;tn=baiduimage&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;word=volatile" onmousedown="setHeadUrl(this)" wdfield="word">图片</a><a href="http://video.baidu.com/v?fr=bk&amp;ct=301989888&amp;rn=20&amp;pn=0&amp;db=0&amp;s=24&amp;word=volatile" onmousedown="setHeadUrl(this)" wdfield="word">视频</a><strong>百科</strong><a href="http://wenku.baidu.com/search?fr=bk&amp;word=volatile&amp;lm=0&amp;od=0" onmousedown="setHeadUrl(this)" wdfield="word">文库</a>
</p>
<form action="http://baike.baidu.com/searchword/" method="get" name="f1" target="_self">
<input autocomplete="off" id="word" maxlength="400" name="word" tabindex="1" value="volatile">
<input class="search-btn nslog:1010" onclick="document.f1.pic.value=1" tabindex="2" value="进入词条" type="submit"><input class="search-btn nslog:1011" onclick="document.f1.pic.value=2" tabindex="3" value="搜索词条" type="submit">
<input id="sw1" name="pic" value="1" type="hidden">
<input name="sug" value="1" type="hidden">
<input id="search-enc" name="enc" value="gbk" type="hidden">
<iframe style="display: none; position: absolute; border-width: 0px;" class="tangram_sug_sd" src="index_3.html"></iframe><div style="display: none;" class="tangram_sug_wpr" id="tangram_sug_1334891272734"></div></form>
</div>
<div id="help">
<a class="nslog:1012" href="http://www.baidu.com/search/baike_help.html" target="_top">帮助</a><a class="nslog:1013" href="#" onclick="setSug();return false">设置</a>
</div>
<div class="clear"></div>

</div><div class="nslog-area" data-nslog-type="1000" id="path">

<ul class="nav f14 clearfix">    
            <li class="home"><a href="http://baike.baidu.com/">首页</a></li>
                <li><a href="http://baike.baidu.com/ziran/">自然</a></li>
                 <li><a href="http://baike.baidu.com/wenhua/">文化</a></li>
                 <li><a href="http://baike.baidu.com/dili/">地理</a></li>
                 <li><a href="http://baike.baidu.com/lishi/">历史</a></li>
                 <li><a href="http://baike.baidu.com/shenghuo/">生活</a></li>
                 <li><a href="http://baike.baidu.com/shehui/">社会</a></li>
                 <li><a href="http://baike.baidu.com/yishu/">艺术</a></li>
                 <li><a href="http://baike.baidu.com/renwu/">人物</a></li>
                 <li><a href="http://baike.baidu.com/jingji/">经济</a></li>
                 <li><a href="http://baike.baidu.com/kexue/">科技</a></li>
                 <li><a href="http://baike.baidu.com/tiyu/">体育</a></li>
                 <li><a href="http://baike.baidu.com/tupian/">图片</a></li>
             <li>          <a href="http://baike.baidu.com/museum/" target="_top" onclick="nslog(location.href,3020);">数字博物馆</a></li>
     <li>          <a href="http://baike.baidu.com/cms/s/core/index.html" target="_top" onclick="nslog(location.href,3021);">核心用户</a></li>
                 <li><a href="http://baike.baidu.com/mall/">百科商城</a></li>
           
</ul>



</div>
</div>
<div id="page">
<div class="layout grid-m0s245 w1000" id="content-wrap">
<div class="col-main article" id="content">
<div class="main-wrap main-shadow" id="main-wrap">
<div class="content-hd">
<div class="content-hd-wrap"></div>
</div>
<div class="content-bd main-body">
<div class="text" id="sec-content0">
<div class="bk-editable-lemma-btns">
<a class="tpldivide-lemma lemma-top-link" hidefocus="true" href="http://baike.baidu.com/tpldivideload?lemmaId=608706" id="tmpdivide" style="display: none; margin-right: 14px;" target="_top"></a>
<a class="dividable-lemma lemma-top-link" data-edit-id="608706" hidefocus="true" href="http://baike.baidu.com/divideload?lemmaid=608706" id="polyin" style="display: none;">拆分词条</a>
<span class="editable-lemma " data-edit-id="608706"></span>
<span style="height: 100%;"></span>
</div>
<h1 class="title" id="lemmaTitle-608706">volatile</h1>


<div class="clear"></div>
<div class="mod-top">
<h4 class="card-title"><span class="throwbtl-link-span" data-edit-id="$$$$608706"><a sublemmaid="" orilemmaid="608706" sublemmatitle="" isviewcard="1" class="throwbtl-link-view" href="#" onclick="if(!window.curUser){nslog(location.href,3721,{fr:8});}userlogin();return false;">求助编辑</a></span>百科名片</h4>
<div class="card-summary nslog-area" data-nslog-type="72">
<div style="width: 100px;" class="pic" id="cardpic0">
<a hidefocus="true" href="http://baike.baidu.com/albums/608706/608706/0/0.html#0$5af4d7ea6349fbedd439c963" target="_top">
<img alt="volatile" class="card-image editorImg" onerror='this.parentNode.parentNode.style.width="150px"' src="5af4d7ea6349fbedd439c963.jpg" title="volatile">
</a>
<a class="card-pic-handle" href="http://baike.baidu.com/albums/608706/608706/0/0.html#0$5af4d7ea6349fbedd439c963" target="_top" title="查看图片">&nbsp;&nbsp;</a>
<div>volatile</div>
</div>
<div class="card-summary-content">
<p>
就象大家更熟悉的const一样，volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么<a target="_top" href="http://baike.baidu.com/view/487018.htm">编译器</a>失去大量优化的机会。</p>
</div>
<div class="clear"></div>
</div>
</div>
<fieldset class="text_dir nslog-area log-set-param" data-nslog-type="1016" data-subindex="0" id="catalog-0" log-set-param="catalogshow">
<p>目录</p>
<dl style="width: 261px; visibility: hidden; padding-bottom: 20px;" class="holder1" id="catalog-holder-0">
<dd><a href="#1" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile的作用</a></dd><dd><a href="#2" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile变量的几个例子</a></dd><dd><a href="#3" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile一般使用的地方</a></dd><dd><a href="#4" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile代码说明</a></dd><dd><a href="#5" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">如何在java中正确使用volatile</a><ol style="display: none;"><li><a href="#5_1">简介：</a></li><li><a href="#5_2">Volatile 变量</a></li><li><a href="#5_3">正确使用 volatile 变量的条件</a></li><li><a href="#5_4">性能考虑</a></li><li><a href="#5_5">正确使用 volatile 的模式</a></li></ol></dd><dd><a href="#6" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">英文单词</a><ol style="display: none;"><li><a href="#6_1">以下结果由译典通提供词典解释</a></li><li><a href="#6_2">以下结果来自互联网网络释义</a></li></ol></dd></dl>
<dl style="width: 261px; display: block;" class="holder2 arr" id="catalog-holder-2-0">
<dd><a href="#1" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile的作用</a></dd><dd><a href="#2" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile变量的几个例子</a></dd><dd><a href="#3" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile一般使用的地方</a></dd><dd><a href="#4" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">volatile代码说明</a></dd><dd><a href="#5" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">如何在java中正确使用volatile</a><ol style="display: none;"><li><a href="#5_1">简介：</a></li><li><a href="#5_2">Volatile 变量</a></li><li><a href="#5_3">正确使用 volatile 变量的条件</a></li><li><a href="#5_4">性能考虑</a></li><li><a href="#5_5">正确使用 volatile 的模式</a></li></ol></dd><dd><a href="#6" class="nslog:1274" name="STAT_ONCLICK_UNSUBMIT_CATALOG">英文单词</a><ol style="display: none;"><li><a href="#6_1">以下结果由译典通提供词典解释</a></li><li><a href="#6_2">以下结果来自互联网网络释义</a></li></ol></dd><div class="nslog:1017 catalog-holder" id="catalog-holder0">展开</div></dl>
</fieldset>
<div class="clear"></div>

<div class="lemma-main-content" id="lemmaContent-0">
<h2 class="headline-1 first bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:1"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,1);return false'>编辑本段</a></span><a name="1"></a><a name="sub608706_1"></a><span class="headline-content">volatile的作用</span></h2>　　<b>volatile</b>的作用: 作为指令关键字,确保本条指令不会因<a target="_top" href="http://baike.baidu.com/view/487018.htm">编译器</a>的优化而省略,且要求每次直接读值.
<div class="spctrl"></div>　　简单地说就是防止编译器对代码进行优化.比如如下程序:
<div class="spctrl"></div>　　XBYTE[2]=0x55;
<div class="spctrl"></div>　　XBYTE[2]=0x56;
<div class="spctrl"></div>　　XBYTE[2]=0x57;
<div class="spctrl"></div>　　XBYTE[2]=0x58;
<div class="spctrl"></div>　　如果对外部硬件上述四条语句分别表示不同的操作,会产生四种不同的动作,那么编译器就不能像对待纯粹的程序那样对上述四条语句进行优化只认为XBYTE[2]=0x58;而忽略前三条语句(即只产生一条机器代码),此时编译器会逐一的进行编译并产生相应的机器代码(四条).<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:2"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,2);return false'>编辑本段</a></span><a name="2"></a><a name="sub608706_2"></a><span class="headline-content">volatile变量的几个例子</span></h2>　　推荐一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 
<div class="spctrl"></div>　　1). 并行设备的硬件寄存器（如：状态寄存器） 
<div class="spctrl"></div>　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 
<div class="spctrl"></div>　　3). 多线程应用中被几个任务共享的变量 
<div class="spctrl"></div>　　回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。 
<div class="spctrl"></div>　　假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是真正懂得volatile完全的重要性。 
<div class="spctrl"></div>　　1). 一个参数既可以是const还可以是volatile吗？解释为什么。 
<div class="spctrl"></div>　　2). 一个指针可以是volatile 吗？解释为什么。 
<div class="spctrl"></div>　　3). 下面的函数有什么错误： 
<div class="spctrl"></div>　　int square(volatile int *ptr) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　return *ptr * *ptr; 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　下面是答案： 
<div class="spctrl"></div>　　1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 
<div class="spctrl"></div>　　2). 是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。 
<div class="spctrl"></div>　　3). 这段代码是个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码： 
<div class="spctrl"></div>　　int square(volatile int *ptr) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　int a,b; 
<div class="spctrl"></div>　　a = *ptr; 
<div class="spctrl"></div>　　b = *ptr; 
<div class="spctrl"></div>　　return a * b; 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： 
<div class="spctrl"></div>　　long square(volatile int *ptr) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　int a; 
<div class="spctrl"></div>　　a = *ptr; 
<div class="spctrl"></div>　　return a * a; 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　讲讲我的理解： （欢迎打板子...~~！） 
<div class="spctrl"></div>　　关键在于两个地方： 
<div class="spctrl"></div>　　1. 编译器的优化 (请高手帮我看看下面的理解) 
<div class="spctrl"></div>　　在本次线程内, 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值； 
<div class="spctrl"></div>　　当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致 
<div class="spctrl"></div>　　当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成<a target="_top" href="http://baike.baidu.com/view/330120.htm">应用程序</a>读取的值和实际的变量值不一致 
<div class="spctrl"></div>　　当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致 
<div class="spctrl"></div>　　举一个不太准确的例子： 
<div class="spctrl"></div>　　发薪资时，会计每次都把员工叫来登记他们的银行卡号；一次会计为了省事，没有即时登记，用了以前登记的银行卡号；刚好一个员工的银行卡丢了，已挂失该银行卡号；从而造成该员工领不到工资 
<div class="spctrl"></div>　　员工 －－ 原始变量地址 
<div class="spctrl"></div>　　银行卡号 －－ 原始变量在寄存器的备份 
<div class="spctrl"></div>　　2. 在什么情况下会出现(如1楼所说) 
<div class="spctrl"></div>　　1). 并行设备的硬件寄存器（如：状态寄存器） 
<div class="spctrl"></div>　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 
<div class="spctrl"></div>　　3). 多线程应用中被几个任务共享的变量 
<div class="spctrl"></div>　　补充： volatile应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人； 
<div class="spctrl"></div>　　“易变”是因为外在因素引起的，象多线程，中断等，并不是因为用volatile修饰了的变量就是“易变”了，假如没有外因，即使用volatile定义，它也不会变化； 
<div class="spctrl"></div>　　而用volatile定义之后，其实这个变量就不会因外因而变化了，可以放心使用了； 大家看看前面那种解释（易变的）是不是在误导人 
<div class="spctrl"></div>　　－－－－－－－－－－－－简明示例如下：－－－－－－－－－－－－－－－－－－ 
<div class="spctrl"></div>　　volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：<a target="_top" href="http://baike.baidu.com/view/880.htm">操作系统</a>、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 
<div class="spctrl"></div>　　使用该关键字的例子如下： 
<div class="spctrl"></div>　　int volatile nVint; 
<div class="spctrl"></div>　　&gt;&gt;&gt;&gt;当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 
<div class="spctrl"></div>　　例如： 
<div class="spctrl"></div>　　volatile int i=10; 
<div class="spctrl"></div>　　int a = i; 
<div class="spctrl"></div>　　... 
<div class="spctrl"></div>　　//其他代码，并未明确告诉编译器，对i进行过操作 
<div class="spctrl"></div>　　int b = i; 
<div class="spctrl"></div>　　&gt;&gt;&gt;&gt;volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样一来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。 
<div class="spctrl"></div>　　&gt;&gt;&gt;&gt;注意，在vc6中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无volatile关键字，对程序最终代码的影响： 
<div class="spctrl"></div>　　&gt;&gt;&gt;&gt;首先，用classwizard建一个win32 console工程，插入一个voltest.cpp文件，输入下面的代码： 
<div class="spctrl"></div>　　&gt;&gt; 
<div class="spctrl"></div>　　#i nclude &lt;stdio.h&gt; 
<div class="spctrl"></div>　　void main() 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　int i=10; 
<div class="spctrl"></div>　　int a = i; 
<div class="spctrl"></div>　　printf("i= %d",a); 
<div class="spctrl"></div>　　//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道 
<div class="spctrl"></div>　　__asm { 
<div class="spctrl"></div>　　mov dword ptr [ebp-4], 20h 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　int b = i; 
<div class="spctrl"></div>　　printf("i= %d",b); 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　然后，在调试版本模式运行程序，输出结果如下： 
<div class="spctrl"></div>　　i = 10 
<div class="spctrl"></div>　　i = 32 
<div class="spctrl"></div>　　然后，在release版本模式运行程序，输出结果如下： 
<div class="spctrl"></div>　　i = 10 
<div class="spctrl"></div>　　i = 10 
<div class="spctrl"></div>　　输出的结果明显表明，release模式下，编译器对代码进行了优化，第二次没有输出正确的i值。下面，我们把 i的声明加上volatile关键字，看看有什么变化： 
<div class="spctrl"></div>　　#i nclude &lt;stdio.h&gt; 
<div class="spctrl"></div>　　void main() 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　volatile int i=10; 
<div class="spctrl"></div>　　int a = i; 
<div class="spctrl"></div>　　printf("i= %d",a); 
<div class="spctrl"></div>　　__asm { 
<div class="spctrl"></div>　　mov dword ptr [ebp-4], 20h 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　int b = i; 
<div class="spctrl"></div>　　printf("i= %d",b); 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　分别在调试版本和release版本运行程序，输出都是： 
<div class="spctrl"></div>　　i = 10 
<div class="spctrl"></div>　　i = 32 
<div class="spctrl"></div>　　这说明这个关键字发挥了它的作用！ 
<div class="spctrl"></div>　　－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ 
<div class="spctrl"></div>　　volatile对应的变量可能在你的程序本身不知道的情况下发生改变 
<div class="spctrl"></div>　　比如多线程的程序，共同访问的内存当中，多个程序都可以操纵这个变量 
<div class="spctrl"></div>　　你自己的程序，是无法判定何时这个变量会发生变化 
<div class="spctrl"></div>　　还比如，他和一个外部设备的某个状态对应，当外部设备发生操作的时候，通过驱动程序和中断事件，系统改变了这个变量的数值，而你的程序并不知道。 
<div class="spctrl"></div>　　对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。 
<div class="spctrl"></div>　　-------------------------------------------------------------------------------- 
<div class="spctrl"></div>　　典型的例子 
<div class="spctrl"></div>　　for ( int i=0; i&lt;100000; i++); 
<div class="spctrl"></div>　　这个语句用来测试空循环的速度的 
<div class="spctrl"></div>　　但是编译器肯定要把它优化掉，根本就不执行 
<div class="spctrl"></div>　　如果你写成 
<div class="spctrl"></div>　　for ( volatile int i=0; i&lt;100000; i++); 
<div class="spctrl"></div>　　它就会执行了 
<div class="spctrl"></div>　　volatile的本意是“易变的” 
<div class="spctrl"></div>　　由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如： 
<div class="spctrl"></div>　　static int i=0; 
<div class="spctrl"></div>　　int main(void) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　... 
<div class="spctrl"></div>　　while (1) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　if (i) dosomething(); 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　/* Interrupt service routine. */ 
<div class="spctrl"></div>　　void ISR_2(void) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　i=1; 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　程序的本意是希望ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在<a target="_top" href="http://baike.baidu.com/view/379148.htm">main函数</a>里面没有修改过i，因此 
<div class="spctrl"></div>　　可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被 
<div class="spctrl"></div>　　调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:3"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,3);return false'>编辑本段</a></span><a name="3"></a><a name="sub608706_3"></a><span class="headline-content">volatile一般使用的地方</span></h2>　　一般说来，volatile用在如下的几个地方： 
<div class="spctrl"></div>　　1、<a target="_top" href="http://baike.baidu.com/view/600257.htm">中断服务程序</a>中修改的供其它程序检测的变量需要加volatile； 
<div class="spctrl"></div>　　2、多任务环境下各任务间共享的标志应该加volatile； 
<div class="spctrl"></div>　　3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义； 
<div class="spctrl"></div>　　另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实 
<div class="spctrl"></div>　　现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:4"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,4);return false'>编辑本段</a></span><a name="4"></a><a name="sub608706_4"></a><span class="headline-content">volatile代码说明</span></h2>　　下面我们来一个个说明。 
<div class="spctrl"></div>　　考虑下面的代码： 
<div class="spctrl"></div>　　代码: 
<div class="spctrl"></div>　　class Gadget 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　public: 
<div class="spctrl"></div>　　void Wait() 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　while (!flag_) 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　Sleep(1000); // sleeps for 1000 milliseconds 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　void Wakeup() 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　flag_ = true; 
<div class="spctrl"></div>　　} 
<div class="spctrl"></div>　　... 
<div class="spctrl"></div>　　private: 
<div class="spctrl"></div>　　bool flag_; 
<div class="spctrl"></div>　　}; 
<div class="spctrl"></div>　　上面代码中Gadget::Wait的目的是每过一秒钟去检查一下flag_成员变量，当flag_被另一个线程设为true时，该函数才会返回。至少这是程序作者的意图，然而，这个Wait函数是错误的。 
<div class="spctrl"></div>　　假设编译器发现Sleep(1000)是调用一个外部的库函数，它不会改变成员变量flag_，那么编译器就可以断定它可以把flag_缓存在寄存器中，以后可以访问该寄存器来代替访问较慢的主板上的内存。这对于单线程代码来说是一个很好的优化，但是在现在这种情况下，它破坏了程序的正确性：当你调用了某个Gadget的Wait函数后，即使另一个线程调用了Wakeup，Wait还是会一直循环下去。这是因为flag_的改变没有反映到缓存它的寄存器中去。编译器的优化未免有点太……乐观了。
<div class="spctrl"></div>　　在大多数情况下，把变量缓存在寄存器中是一个非常有价值的优化方法，如果不用的话很可惜。C和C++给你提供了显式禁用这种缓存优化的机会。如果你声明变量是使用了volatile修饰符，编译器就不会把这个变量缓存在寄存器里——每次访问都将去存取变量在内存中的实际位置。这样你要对Gadget的Wait/Wakeup做的修改就是给flag_加上正确的修饰： 
<div class="spctrl"></div>　　class Gadget 
<div class="spctrl"></div>　　{ 
<div class="spctrl"></div>　　public: 
<div class="spctrl"></div>　　... as above ... 
<div class="spctrl"></div>　　private: 
<div class="spctrl"></div>　　volatile bool flag_; 
<div class="spctrl"></div>　　};
<div class="spctrl"></div>　　在Java中设置变量值的操作，除了long和double类型的变量外都是<a target="_top" href="http://baike.baidu.com/view/809659.htm">原子操作</a>，也就是说，对于变量值的简单读写操作没有必要进行同步。
<div class="spctrl"></div>　　这在JVM 1.2之前，Java的内存模型实现总是从主存读取变量，是不需要进行特别的注意的。而随着JVM的成熟和优化，现在在多线程环境下volatile<a target="_top" href="http://baike.baidu.com/view/390935.htm">关键字</a>的使用变得非常重要。
<div class="spctrl"></div>　　在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。
<div class="spctrl"></div>　　要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。
<div class="spctrl"></div>　　Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
<div class="spctrl"></div>　　<a target="_top" href="http://baike.baidu.com/view/229611.htm">Java语言</a>规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。
<div class="spctrl"></div>　　这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。
<div class="spctrl"></div>　　而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。
<div class="spctrl"></div>　　使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。
<div class="spctrl"></div>　　由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:5"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,5);return false'>编辑本段</a></span><a name="5"></a><a name="sub608706_5"></a><span class="headline-content">如何在java中正确使用volatile</span></h2><h3 class="headline-2 bk-sidecatalog-title"><a name="5_1"></a><a name="sub608706_5_1"></a><span class="headline-content">简介：</span></h3>　　Java? 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量。这两种机制的提出都是为了实现代码线程的安全性。其中 Volatile 变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。在这期的 <i>Java 理论与实践</i>中，Brian Goetz 将介绍几种正确使用 volatile 变量的模式，并针对其适用性限制提出一些建议。
<div class="spctrl"></div>　　Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。本文介绍了几种有效使用 volatile 变量的模式，并强调了几种不适合使用 volatile 变量的情形。
<div class="spctrl"></div>　　锁提供了两种主要特性：<i>互斥（mutual exclusion）</i>和<i>可见性（visibility）</i>。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。<h3 class="headline-2 bk-sidecatalog-title"><a name="5_2"></a><a name="sub608706_5_2"></a><span class="headline-content">Volatile 变量</span></h3>　　Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。
<div class="spctrl"></div>　　出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。<h3 class="headline-2 bk-sidecatalog-title"><a name="5_3"></a><a name="sub608706_5_3"></a><span class="headline-content">正确使用 volatile 变量的条件</span></h3>　　您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
<div class="spctrl"></div>　　● 对变量的写操作不依赖于当前值。
<div class="spctrl"></div>　　● 该变量没有包含在具有其他变量的不变式中。
<div class="spctrl"></div>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。
<div class="spctrl"></div>　　第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）
<div class="spctrl"></div>　　大多数编程情形都会与这两个条件的其中之一冲突，使得 volatile 变量不能像 synchronized 那样普遍适用于实现线程安全。清单 1 显示了一个非线程安全的数值范围类。它包含了一个不变式 —— 下界总是小于或等于上界。
<div class="spctrl"></div>　　<b>清单 1. 非线程安全的数值范围类</b>
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>@NotThreadSafe 
<br>public class NumberRange {
<br>private int lower, upper;
<br>public int getLower() { return lower; }
<br>public int getUpper() { return upper; }
<br>public void setLower(int value) { 
<br>if (value &gt; upper) 
<br>throw new IllegalArgumentException(...);
<br>lower = value;
<br>}
<br>public void setUpper(int value) { 
<br>if (value &lt; lower) 
<br>throw new IllegalArgumentException(...);
<br>upper = value;
<br>}
<br>}</td></tr></tbody></table>　这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。<h3 class="headline-2 bk-sidecatalog-title"><a name="5_4"></a><a name="sub608706_5_4"></a><span class="headline-content">性能考虑</span></h3>　　使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。
<div class="spctrl"></div>　　很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 VM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。
<div class="spctrl"></div>　　volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。<h3 class="headline-2 bk-sidecatalog-title"><a name="5_5"></a><a name="sub608706_5_5"></a><span class="headline-content">正确使用 volatile 的模式</span></h3>　　很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。
<div class="spctrl"></div>　　<b>模式 #1：状态标志</b> 也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。
<div class="spctrl"></div>　　很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如清单 2 所示：
<div class="spctrl"></div>　　<b>清单 2. 将 volatile 变量作为状态标志使用</b>
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>volatile boolean shutdownRequested;
<br>...
<br>public void shutdown() { shutdownRequested = true; }
<br>public void doWork() { 
<br>while (!shutdownRequested) { 
<br>// do stuff
<br>}
<br>}</td></tr></tbody></table>　很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。
<div class="spctrl"></div>　　这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。
<div class="spctrl"></div>　　<b>模式 #2：一次性安全发布（one-time safe publication）</b>
<div class="spctrl"></div>　　缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。
<div class="spctrl"></div>　　实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。清单 3 展示了一个示例，其中后台线程在启动阶段从数据库加载一些数据。其他代码在能够利用这些数据时，在使用之前将检查这些数据是否曾经发布过。
<div class="spctrl"></div>　　<b>清单 3. 将 volatile 变量用于一次性安全发布</b>
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>public class BackgroundFloobleLoader {
<br>public volatile Flooble theFlooble;
<br>public void initInBackground() {
<br>// do lots of stuff
<br>theFlooble = new Flooble(); // this is the only write to theFlooble
<br>}
<br>}
<br>public class SomeOtherClass {
<br>public void doWork() {
<br>while (true) { 
<br>// do some stuff...
<br>// use the Flooble, but only if it is ready
<br>if (floobleLoader.theFlooble != null) 
<br>doSomething(floobleLoader.theFlooble);
<br>}
<br>}
<br>}</td></tr></tbody></table>　如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。
<div class="spctrl"></div>　　该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。
<div class="spctrl"></div>　　<b>模式 #3：独立观察（independent observation）</b>
<div class="spctrl"></div>　　安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。
<div class="spctrl"></div>　　使用该模式的另一种应用程序就是收集程序的统计信息。清单 4 展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。
<div class="spctrl"></div>　　清单 4. 将 volatile 变量用于多个独立观察结果的发布
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>public class UserManager {
<br>public volatile String lastUser;
<br>public boolean authenticate(String user, String password) {
<br>boolean valid = passwordIsValid(user, password);
<br>if (valid) {
<br>User u = new User();
<br>activeUsers.add(u);
<br>lastUser = user;
<br>}
<br>return valid;
<br>}
<br>} </td></tr></tbody></table>　该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。
<div class="spctrl"></div>　　<b>模式 #4：“volatile bean” 模式</b>
<div class="spctrl"></div>　　volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和/或 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。
<div class="spctrl"></div>　　在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。清单 5 中的示例展示了遵守 volatile bean 模式的 JavaBean：
<div class="spctrl"></div>　　<b>清单 5. 遵守 volatile bean 模式的 Person 对象</b>
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>@ThreadSafe
<br>public class Person {
<br>private volatile String firstName;
<br>private volatile String lastName; 
<br>private volatile int age;
<br>public String getFirstName() { return firstName; }
<br>public String getLastName() { return lastName; }
<br>public int getAge() { return age; }
<br>public void setFirstName(String firstName) { 
<br>this.firstName = firstName;
<br>}
<br>public void setLastName(String lastName) { 
<br>this.lastName = lastName;
<br>}
<br>public void setAge(int age) { 
<br>this.age = age;
<br>}
<br>}</td></tr></tbody></table><b>volatile 的高级模式</b>
<div class="spctrl"></div>　　前面几节介绍的模式涵盖了大部分的基本用例，在这些模式中使用 volatile 非常有用并且简单。这一节将介绍一种更加高级的模式，在该模式中，volatile 将提供性能或可伸缩性优势。
<div class="spctrl"></div>　　volatile 应用的的高级模式非常脆弱。因此，必须对假设的条件仔细证明，并且这些模式被严格地封装了起来，因为即使非常小的更改也会损坏您的代码！同样，使用更高级的 volatile 用例的原因是它能够提升性能，确保在开始应用高级模式之前，真正确定需要实现这种性能获益。需要对这些模式进行权衡，放弃可读性或可维护性来换取可能的性能收益 —— 如果您不需要提升性能（或者不能够通过一个严格的测试程序证明您需要它），那么这很可能是一次糟糕的交易，因为您很可能会得不偿失，换来的东西要比放弃的东西价值更低。
<div class="spctrl"></div>　　<b>模式 #5：开销较低的读－写锁策略</b>
<div class="spctrl"></div>　　目前为止，您应该了解了 volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。
<div class="spctrl"></div>　　然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。清单 6 中显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。
<div class="spctrl"></div>　　<b><b>清单 6. 结合使用 volatile 和 synchronized 实现 “开销较低的读－写锁” </b></b>
<div class="spctrl"></div>　　<table class="table-view log-set-param" log-set-param="table_view"><tbody><tr><td>
<br>@ThreadSafe
<br>public class CheesyCounter {
<br>// Employs the cheap read-write lock trick
<br>// All mutative operations MUST be done with the 'this' lock held
<br>@GuardedBy("this") private <b>volatile</b>int value;
<br>public int getValue() { return value; }
<br>public <b>synchronized</b>int increment() {
<br>return value++;
<br>}
<br>}</td></tr></tbody></table>　之所以将这种技术称之为 “开销较低的读－写锁” 是因为您使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 您必须使用锁。然而，您可以在读操作中使用 volatile 确保当前值的<i>可见性</i>，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。
<div class="spctrl"></div>　　<b>结束语</b>
<div class="spctrl"></div>　　与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。本文介绍的模式涵盖了可以使用 volatile 代替 synchronized 的最常见的一些用例。遵循这些模式（注意使用时不要超过各自的限制）可以帮助您安全地实现大多数用例，使用 volatile 变量获得更佳性能。<div class="bpctrl"></div><h2 class="headline-1 bk-sidecatalog-title"><span class="text_edit editable-title" data-edit-id="608706:608706:6"><a href="#" class="nslog:1019" onclick='bk.view.editLemma("/edit/",608706,608706,6);return false'>编辑本段</a></span><a name="6"></a><a name="sub608706_6"></a><span class="headline-content">英文单词</span></h2>　　volatile英音：['v?l?tail]美音：['vɑl?t!]<h3 class="headline-2 bk-sidecatalog-title"><a name="6_1"></a><a name="sub608706_6_1"></a><span class="headline-content">以下结果由译典通提供词典解释</span></h3>　　<b>形容词 a. 
<div class="spctrl"></div>　　</b>1. (液体等)易挥发的
<div class="spctrl"></div>　　Gasoline is volatile. 
<div class="spctrl"></div>　　汽油是易挥发的。 
<div class="spctrl"></div>　　2. 易发作的;爆炸性的
<div class="spctrl"></div>　　The situation in that area was tense, dangerous and volatile. 
<div class="spctrl"></div>　　该地区的局势紧张、危险,且有一触即发之势。 
<div class="spctrl"></div>　　3. 易变的;反复无常的;轻浮的
<div class="spctrl"></div>　　4. 活泼的;轻快的
<div class="spctrl"></div>　　5. 飞逝的;短暂的<h3 class="headline-2 bk-sidecatalog-title"><a name="6_2"></a><a name="sub608706_6_2"></a><span class="headline-content">以下结果来自互联网网络释义</span></h3>　　<b>volatile
<div class="spctrl"></div>　　</b>1. 反复无常的，挥发性的
<div class="spctrl"></div>　　托福词汇小结（1） - 完美学社 <a target="_top" href="http://baike.baidu.com/view/1735.htm">上海</a>学习...volatile adj．反复无常的，挥发性的
<div class="spctrl"></div>　　2. 易挥发的、易变的
<div class="spctrl"></div>　　编程术语英语翻译-外贸英语-外贸论坛volatile 易挥发的、易变的 
<div class="spctrl"></div>　　3. 挥发分
<div class="spctrl"></div>　　翻译资源网??? 挥发分 volatile 
<div class="spctrl"></div>　　using System;
<div class="spctrl"></div>　　using System.Collections.Generic;
<div class="spctrl"></div>　　using System.Linq;
<div class="spctrl"></div>　　using System.Text;
<div class="spctrl"></div>　　namespace Singleton单件模式多线程
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　//在多线程环境下
<div class="spctrl"></div>　　public class Singleton
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　private static volatile Singleton instance = null; //volatile关键字
<div class="spctrl"></div>　　private static object lockHelper = new Object(); //辅助型对象
<div class="spctrl"></div>　　//私有的构造函数
<div class="spctrl"></div>　　private Singleton()
<div class="spctrl"></div>　　{ }
<div class="spctrl"></div>　　public static Singleton Instance
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　get
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　if (instance == null)
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　lock (lockHelper) //加锁，防止其他线程进入
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　if (instance == null) //双检查
<div class="spctrl"></div>　　{
<div class="spctrl"></div>　　instance = new Singleton();
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　return instance;
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　}
<div class="spctrl"></div>　　}<div class="bpctrl" style="clear: both;"></div><div class="clear"></div>
</div>
<div class="clear"></div>

<div class="reinforce" id="lemmaExtend">
<dl class="nslog-area log-set-param" data-nslog-type="1" id="viewExtRead" log-set-param="ext_reader">
<dt>扩展阅读：</dt>
<dd class="reference">
<ul>
<li class="layout">
<span class="ref-index"><span class="r-index">1</span><span class="slide s-right"></span></span>
<p class="ref-bd line-1">volatile编写多线程程序的好帮手     选择自 lphpc 的 Blog</p>
</li>
<li class="layout">
<span class="ref-index"><span class="r-index">2</span><span class="slide s-right"></span></span>
<p class="ref-bd line-1"><a target="_top" href="http://dev.csdn.net/develop/article/83/83923.shtm">http://dev.csdn.net/develop/article/83/83923.shtm</a></p>
</li>
</ul>
</dd>
</dl>
<dl class="nslog-area log-set-param" data-nslog-type="19" id="viewExtCati" log-set-param="module_tag">
<dt>开放分类：</dt>
<dd>
<a href="http://baike.baidu.com/taglist?tag=%B1%E0%B3%CC&amp;tagfromview" target="_top">编程</a>，<a href="http://baike.baidu.com/taglist?tag=C&amp;tagfromview" target="_top">C</a>，<a href="http://baike.baidu.com/taglist?tag=C%2B%2B&amp;tagfromview" target="_top">C++</a>，<a href="http://baike.baidu.com/taglist?tag=JAVA&amp;tagfromview" target="_top">JAVA</a></dd>
</dl>
<div class="clear"></div>
<div class="clear"></div>
</div>

</div>
<div class="clear"></div>
</div>
<div class="content-ft">
<div class="reinforce">
<dl class="nslog-area" data-nslog-type="17" id="bkDict">
<dt>“volatile”在英汉词典中的解释<span>(来源：<a href="http://dict.baidu.com/s?f=8&amp;wd=volatile" target="_top">百度词典</a>)：</span></dt>
<dd>
<div class="ptitle">volatile<br>KK: [<img src="053.gif" align="absbottom" border="0"><img src="043.gif" align="absbottom" border="0"><img src="007.gif" align="absbottom" border="0"><img src="049.gif" align="absbottom" border="0"><img src="018.gif" align="absbottom" border="0"><img src="039.gif" align="absbottom" border="0"><img src="057.gif" align="absbottom" border="0">]<br>DJ: [<img src="053.gif" align="absbottom" border="0"><img src="043.gif" align="absbottom" border="0"><img src="016.gif" align="absbottom" border="0"><img src="049.gif" align="absbottom" border="0"><img src="018.gif" align="absbottom" border="0"><img src="039.gif" align="absbottom" border="0"><img src="002.gif" align="absbottom" border="0"><img src="033.gif" align="absbottom" border="0"><img src="049.gif" align="absbottom" border="0">]</div><div class="pcixin">a.</div><div class="pexplain">1. (液体等)易挥发的</div><div class="pexplain">2. 易发作的;爆炸性的</div><div class="pexplain">3. 易变的;反复无常的;轻浮的</div><div class="pexplain">4. 活泼的;轻快的</div><div class="pexplain">5. 飞逝的;短暂的</div><a href="http://dict.baidu.com/s?ie=gb2312&amp;ct=1048576&amp;cl=3&amp;f=8&amp;word=volatile" target="_top">查看例句</a></dd>
</dl>
</div>
<div class="reinforce">
<dl class="nslog-area" data-nslog-type="18" id="relatedLemmaDown">
<dt>
“volatile”相关词条：
</dt>
<dd class="relative">
<div class="clear"></div>
<div>
<a class="relatedhelp" href="http://www.baidu.com/search/baike_help.html#%E5%A6%82%E4%BD%95%E5%AE%8C%E5%96%84%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%9D%A1" target="_top" title="什么是相关词条">什么是相关词条</a>
<a class="myedit nslog:1005" href="#" onclick='userlogin.check(bk.view.editRelated,false,"editrelated");return false'>我来完善</a>
</div>
<div class="clear"></div>
</dd>
</dl>
</div>
<div class="clear"></div>
<div class="clear"></div>
<div class="end">
<p class="declare">百度百科中的词条内容仅供参考，如果您需要解决具体问题（尤其在法律、医学等领域），建议您咨询相关领域专业人士。</p>
<div class="text_vote1" id="vote_btn"><b id="vote_num">827</b><span id="vote_txt">本词条对我有帮助</span></div>
</div><div class="layout share">
<div class="share-item-title">
<a class="cang nslog:99" href="http://cang.baidu.com/do/add" onclick='window.open("http://cang.baidu.com/do/add?it="+encodeURIComponent(document.title)+"&amp;iu="+encodeURIComponent(location.href)+"&amp;tn=%E7%99%BE%E7%A7%91%E8%AF%8D%E6%9D%A1%2C&amp;fr=bk#nw=1","_s","scrollbars=no,width=600,height=450,left=75,top=20,status=no,resizable= yes");return false' target="_top" title="添加到搜藏">添加到搜藏</a>
</div>
<div class="share-item clearfix" id="bdsharebox">
<span class="share-tip">分享到:</span>
<div class="bdshare_t bds_tools get-codes-bdshare" data="{'url':'http://baike.baidu.com/view/608706.htm','text':'【volatile_百度百科】就象大家更熟悉的const一样，volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的......','pic':'http://imgsrc.baidu.com/baike/abpic/item/5af4d7ea6349fbedd439c963.jpg','wbuid':1647247597}" id="bdshare">
<a title="分享到新浪微博" class="bds_tsina"></a>
<a title="分享到腾讯微博" class="bds_tqq"></a>
<a title="分享到豆瓣网" class="bds_douban"></a>
<a title="分享到搜狐微博" class="bds_tsohu"></a>
<a title="分享到网易微博" class="bds_t163"></a>
<a title="分享到人人网" class="bds_renren"></a>
<span class="bds_more">更多</span>
</div>


</div>
</div>
<dl class="lemma-ext-bottom nslog-area" data-nslog-type="16">
<dt>合作编辑者</dt>
<dd>
<div class="onelineonly">
<span id="co-editors">
<span>
<a title="查看此用户资料" class="usercard" username="ziven_ma" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=ziven_ma#3">ziven_ma</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="炫作展示" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=%EC%C5%D7%F7%D5%B9%CA%BE#3">炫作展示</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="stef_goddess" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=stef_goddess#3">stef_goddess</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="nxgliming" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=nxgliming#3">nxgliming</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="zhangze_365" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=zhangze_365#3">zhangze_365</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="handsome_p_fox" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=handsome_p_fox#3">handsome_p_fox</a></span>
<span>
，<a title="查看此用户资料" class="usercard" username="hczhiyue" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=hczhiyue#3">hczhiyue</a></span>



</span>
</div>
<a class="f12 ref_more" href="http://baike.baidu.com/update/id=608706?from=au" id="more-coeditor" style="" target="_top">更多</a>
<div class="clear"></div>
<div class="try f12">如果您认为本词条还需进一步完善，百科欢迎您也来参与<a class="try-edit" href="#" onclick='bk.view.editLemma("/edit/","608706");return false'>编辑词条</a>在开始编辑前，您还可以先学习<a href="http://www.baidu.com/search/baike_help.html#%E7%BC%96%E8%BE%91%E5%8E%9F%E5%88%99" target="_top">如何编辑词条</a></div>
</dd>
</dl>
<p class="bk-feedback">
如想投诉，请到<a class="nslog:1006" href="http://tousu.baidu.com/baike" target="_top">百度百科投诉中心</a>；如想提出意见、建议，请到<a class="nslog:1007" href="http://tieba.baidu.com/f?kw=%b0%d9%b6%c8%b0%d9%bf%c6" target="_top">百度百科吧</a>。
</p>
<div class="clear"></div>
</div>
</div>
</div>
<div class="col-sub" id="side">
<div class="userinfo-side">
<div id="userInfoDiv">
</div>
</div>
<div class="box2" id="lemma-overview">
<div class="box2-inner">
<h2>词条统计</h2>
<p class="info f12">
浏览次数：约 <span id="viewPV">190722</span>
次
<br>
编辑次数：21次 <a class="nslog:1021" href="http://baike.baidu.com/update/id=608706" target="_top">历史版本</a>
<br>
最近更新：<span id="lastModifyTime">2012-03-01</span>
<br>
创建者：<span class="nslog:1022"><a title="查看此用户资料" class="usercard" username="RiseWind" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=RiseWind#3">RiseWind</a></span>
</p>
</div>
</div>

<div class="box2 nslog-area" id="pro-contributors">
<div class="box2-inner">
<h2><span><a href="http://baike.baidu.com/update/id=608706" target="_top">更多</a></span>贡献光荣榜</h2>
<div id="contri-div">
<table class="topuser f12" border="0" cellpadding="0" cellspacing="0" width="235px;">
<tbody><tr>
<td class="contri-type" colspan="4"><strong>辛勤贡献者：</strong><img class="what" src="blank.gif" title="贡献复杂版本，被称为辛勤贡献者" align="absmiddle"></td>
</tr>
<tr>
<td width="18">
</td>
<th width="100"><a title="查看此用户资料" class="usercard" username="handsome_p_fox" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=handsome_p_fox#3">handsome_p_fox</a></th>
<td align="right" width="60">
<a href="http://www.baidu.com/search/baike_help.html#%E7%99%BE%E7%A7%91%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB" target="_top"><img class="usertitle level2" src="blank.gif" style="width: 60px;" align="absmiddle"></a>
</td>
<td align="right" width="74">
<a href="http://www.baidu.com/search/baike_help.html#%E5%A4%8D%E6%9D%82%E7%BC%96%E8%BE%91" target="_top"><img src="complex.png" title="为词条改进贡献了复杂版本的用户，被称为辛勤贡献者" align="absmiddle"></a>&nbsp;
<a class="contri-a nslog:1040" href="http://baike.baidu.com/history/id=18674764" target="_top">版本</a>
</td>
</tr>
<tr>
<td width="18">
</td>
<th width="100"><a title="查看此用户资料" class="usercard" username="RiseWind" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=RiseWind#3">RiseWind</a></th>
<td align="right" width="60">
<a href="http://www.baidu.com/search/baike_help.html#%E7%99%BE%E7%A7%91%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB" target="_top"><img class="usertitle level2" src="blank.gif" style="width: 60px;" align="absmiddle"></a>
</td>
<td align="right" width="74">
<a href="http://www.baidu.com/search/baike_help.html#%E5%A4%8D%E6%9D%82%E7%BC%96%E8%BE%91" target="_top"><img src="complex.png" title="为词条改进贡献了复杂版本的用户，被称为辛勤贡献者" align="absmiddle"></a>&nbsp;
<a class="contri-a nslog:1040" href="http://baike.baidu.com/history/id=5147400" target="_top">版本</a>
</td>
</tr>
<tr>
<td width="18">
</td>
<th width="100"><a title="查看此用户资料" class="usercard" username="lison369" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=lison369#3">lison369</a></th>
<td align="right" width="60">
<a href="http://www.baidu.com/search/baike_help.html#%E7%99%BE%E7%A7%91%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB" target="_top"><img class="usertitle level2" src="blank.gif" style="width: 60px;" align="absmiddle"></a>
</td>
<td align="right" width="74">
<a href="http://www.baidu.com/search/baike_help.html#%E5%A4%8D%E6%9D%82%E7%BC%96%E8%BE%91" target="_top"><img src="complex.png" title="为词条改进贡献了复杂版本的用户，被称为辛勤贡献者" align="absmiddle"></a>&nbsp;
<a class="contri-a nslog:1040" href="http://baike.baidu.com/history/id=7493519" target="_top">版本</a>
</td>
</tr>
<tr>
<td width="18">
</td>
<th width="100"><a title="查看此用户资料" class="usercard" username="iwjcsg2009" target="_top" href="http://passport.baidu.com/?business&amp;aid=7&amp;default_tab=2&amp;un=iwjcsg2009#3">iwjcsg2009</a></th>
<td align="right" width="60">
<a href="http://www.baidu.com/search/baike_help.html#%E7%99%BE%E7%A7%91%E7%A7%AF%E5%88%86%E4%BD%93%E7%B3%BB" target="_top"><img class="usertitle level2" src="blank.gif" style="width: 60px;" align="absmiddle"></a>
</td>
<td align="right" width="74">
<a href="http://www.baidu.com/search/baike_help.html#%E5%A4%8D%E6%9D%82%E7%BC%96%E8%BE%91" target="_top"><img src="complex.png" title="为词条改进贡献了复杂版本的用户，被称为辛勤贡献者" align="absmiddle"></a>&nbsp;
<a class="contri-a nslog:1040" href="http://baike.baidu.com/history/id=13889088" target="_top">版本</a>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="box2" id="bkDynamic" style="">
<div class="box2-inner">
<h5 id="profileTitle">最新动态</h5>
<div class="f12">
<dl class="task nslog-area" data-nslog-type="1023" id="task" style=""><dt><strong>世界地球日活动</strong>：<a href="http://baike.baidu.com/cms/s/earthday2012/index.html" target="_top"></a></dt> <dd><a href="http://baike.baidu.com/cms/s/earthday2012/index.html" target="_top"><img src="ecf3ddb6771dece965621f25d460f5dc.jpg" height="81" width="160"></a></dd></dl>
<dl class="notice nslog-area" data-nslog-type="1024" id="notice"><dt><strong>百科消息</strong>：</dt><dd><a href="http://baike.baidu.com/cms/s/baikekehuduan/index.html?name=baikekehuduan&amp;fr=bkhomebaikekehuduan" target="_top">无线百科全书iphone版</a></dd><dd><a href="http://baike.baidu.com/cms/s/bkguide/index.html" target="_top">百科新手指南助你做知识达人</a></dd><dd><a href="http://hi.baidu.com/bkcz/blog/" target="_top">百科航海日志-船长分享成长点滴</a></dd><dd><a href="http://wenku.baidu.com/topic/technology.html?fr=baike" target="_top">百度技术沙龙讲稿集锦</a></dd><dd><a href="http://lvyou.baidu.com/event/s/traveler-bible/index.html?from=baike" target="_top">百度旅游《行者圣经》作者招募</a></dd><dd><a href="http://s.baidu.com/beijing/promo?_f=nav" target="_top">百度身边人气餐厅优惠放送</a></dd></dl>
</div>
</div>
</div>
<div class="box2" id="mabox" style="display: none;">
<div class="box2-inner" id="box2-inner">


</div>
</div>
<div class="clear">
</div>
</div>
</div><img src="c.gif" style="display: none;"><input id="titleVal" value="volatile" type="hidden">
</div>
<div class="nslog-area" data-nslog-type="1001" id="footer">
© 2012 Baidu <a href="http://www.baidu.com/duty/" target="_top">使用百度前必读</a>
|
<a href="http://www.baidu.com/search/baike_help.html#%E7%99%BE%E7%A7%91%E5%8D%8F%E8%AE%AE" target="_top">百科协议</a>
|
<a href="http://baike.baidu.com/hezuo/" target="_top">百度百科合作平台</a>
</div>
</div>
<div id="sidecatalog" style="position: fixed; top: 431px; left: 744px;">
<div class="sidebar" id="sidebar"></div>
<a class="gotop" href="#" id="gotop" title="返回顶部"></a>
</div>
<div id="side-catalog-content" style="display: none; position: fixed; overflow: hidden; height: 356px; top: 165px; left: 771px;"><div id="side-catalog-up"><div></div></div><div id="side-lemma-title">volatile</div><div style="height: 286px;" id="side-title-panel"><div id="side-title-list"><h2><a href="#1" class="nslog:1026" title="volatile的作用">volatile的作用</a></h2><h2><a href="#2" class="nslog:1026" title="volatile变量的几个例子">volatile变量的几个例子</a></h2><h2><a href="#3" class="nslog:1026" title="volatile一般使用的地方">volatile一般使用的地方</a></h2><h2><a href="#4" class="nslog:1026" title="volatile代码说明">volatile代码说明</a></h2><h2><a href="#5" class="nslog:1026" title="如何在java中正确使用volatile">如何在java中正确使用volatile</a></h2><h3><a href="#5_1" class="nslog:1026" title="简介：">简介：</a></h3><h3><a href="#5_2" class="nslog:1026" title="Volatile 变量">Volatile 变量</a></h3><h3><a href="#5_3" class="nslog:1026" title="正确使用 volatile 变量的条件">正确使用 volatile 变量的条件</a></h3><h3><a href="#5_4" class="nslog:1026" title="性能考虑">性能考虑</a></h3><h3><a href="#5_5" class="nslog:1026" title="正确使用 volatile 的模式">正确使用 volatile 的模式</a></h3><h2><a href="#6" class="nslog:1026" title="英文单词">英文单词</a></h2><h3><a href="#6_1" class="nslog:1026" title="以下结果由译典通提供词典解释">以下结果由译典通提供词典解释</a></h3><h3><a href="#6_2" class="nslog:1026" title="以下结果来自互联网网络释义">以下结果来自互联网网络释义</a></h3></div></div><div id="side-catalog-down"><div></div></div></div>




<div id="usercard-wrap"><div style="opacity: 0;" class="user-card fix"><div class="top-bg"></div><div class="card-body fix"><div class="uc-l"><div class="uc-pic"></div><div class="uc-name"><a class="uc-id" href="http://baike.baidu.com/view/608706.htm"></a></div><div class="uc-level"></div></div><div class="uc-r"><div class="uc-items"><div class="uc-role fix"></div><div class="uc-badge fix"></div><div class="uc-honor"></div><div class="uc-going-task fix"></div><div class="uc-gq"></div><div class="uc-default"></div><div class="uc-edit"></div></div><span class="pillar"></span></div></div></div></div></body>
</html>
